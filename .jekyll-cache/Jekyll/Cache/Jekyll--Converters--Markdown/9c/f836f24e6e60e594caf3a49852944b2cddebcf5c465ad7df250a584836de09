I""<h1 id="innkapsling-og-validering---teorispørsmål">Innkapsling og validering - Teorispørsmål</h1>

<ol>
  <li>
    <p><span style="color=#172b4d;">a) Hva er forskjellen på </span><strong>public</strong><span style="color=#172b4d;">, </span><strong>protected</strong><span style="color=#172b4d;"> og </span><strong>private</strong><span style="color=#172b4d;">?</span><span style="color=#172b4d;">
</span><strong>public</strong><span style="color=#980000;"> brukes når andre klasser skal kunne instansiere klassen direkte med </span>**new <klasse>(…)**<span style="color=#980000;">. </span>**protected**<span style="color=#980000;">-konstruktører brukes for å initialisere felt i en superklasse og kalles av subklassens konstruktør med </span>**super(…)**<span style="color=#980000;">. </span>**private**<span style="color=#980000;"> brukes på hjelpekonstruktører internt i en klasse og kalles med </span>**this(…)**<span style="color=#980000;">.</span><span style="color=#172b4d;">
b) Hva bør i utgangspunktet alle variablene dine være deklarert som? </span><span style="color=#172b4d;">
</span><span style="color=#980000;">Innkapsling handler om å: 
1) hindre at en kan sette objekter til en ulovlig tilstand og 
2) skjule representasjonsdetaljer slik at en kan gjøre endringer uten at andre klasser også må endres. </span></klasse></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvilke to metoder er vanlig å ha for variabler i Java? </span><span style="color=#172b4d;">
</span><span style="color=#980000;">Generelt er det en fordel å redusere settet med metoder, siden det gir frihet til å endre klasse siden. Når felt initaliseres i en konstruktør, så trengs som oftest ikke set-metoder. Her trenger en heller ikke get-metoder, siden metodene som stiller spørsmål og sjekker svar utgjør et komplett API for klassen.</span></p>
  </li>
</ol>

<p>&lt;/span&gt;<span style="color=#980000;">get-metoder gir tilgang til tilstanden uten å “avsløre” hvilke felt som brukes for å representere tilstanden.</span></p>

<ol>
  <li>
    <p><span style="color=#172b4d;">Hva er forskjellen på ugyldig tilstand og ugyldig argument? </span><span style="color=#172b4d;">
</span><span style="color=#980000;">Hva er formålet med / begrunnelsen for å implementere en eller flere konstruktører for en klasse : En konstruktør har som formål å </span><em>initialisere *<span style="color=#980000;">et objekt, slik at det fra starten av har en </span></em>gyldig *<span style="color=#980000;">tilstand.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hva er meningen med innkapsling og validering? </span><span style="color=#172b4d;">
</span><span style="color=#980000;">Innkapsling skal sikre et objekt starter og forblir i en </span><em>gyldig tilstand</em><span style="color=#980000;"> og at innholdet kan leses og endres uten å avdekke den </span><em>interne representasjonen og implementasjonen</em><span style="color=#980000;">. Mekanismen er bruk av synlighetsmodifikatorer, som reduserer muligheten (andre) klasser har til å referere til felt og metoder.
</span><span style="color=#172b4d;">
</span><span style="color=#980000;">En kan kategorisere innkapslingsmetoder som enten lese- eller endringsmetoder. Den viktigste oppgaven til endringsmetodene, bortsett fra å utføre selve endringen er å sjekke (validere) om den nye verdien (eller nye verdiene) er lovlige/gyldige, før de evt. endres, f.eks. at et navn kun inneholder bokstaver og mellomrom.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Trenger man å validere argumenter som tas inn i konstruktøren? </span></p>
  </li>
</ol>

<p><strong>public final int hours, minutes;
final</strong><span style="color=#980000;"> betyr her at feltet ikke kan endres </span><em>etter</em><span style="color=#980000;"> at det er satt i konstruktøren. </span><span style="color=#980000;">Selv om feltene er </span><strong>public</strong><span style="color=#980000;"> så sikres innkapsling ved at felt-verdiene forblir korrekte, siden kode utenfor klassen ikke kan sette feltene til ugyldige verdier Imidlertid er det ikke i tråd med innkapsling at kode gjøres avhengig av at data er lagret i spesifikke felt. Ved bruk av get-metoder får implementasjonsklassen større frihet til å endre interne detaljer, uten at annen kode blir påvirket.</span></p>

<p><strong>final</strong><span style="color=#980000;"> betyr her at feltet ikke skal kunne endres etter at det er initialisert. Da må en enten initialisere i deklarasjonen eller i en eller flere konstruktører, eller en kombinasjon.</span></p>

<p>&lt;/span&gt;<span style="color=#980000;">Klasser utformet slik at instanser ikke skal kunne endres etter at de er opprettet, </span><em>generelle</em><span style="color=#980000;"> fordeler og ulemper med klasser som gir ikke-modifiserbare (immutable) instanser er at klassen blir enklere, og minsker bl.a. behovet for validering. Instanser kan brukes av flere deler av et program, uten risiko for at en del endrer på dem og ødelegger for en annen del. Ulempen er at en må lage nye instanser hvis de må rettes på, istedenfor å endre dem direkte.</span></p>

<p><span style="color=#980000;">Den generelle teknikken og navnekonvensjonen(e) for å representere og kapsle inn en enkel verdi, f.eks. tall eller objektreferanse, som skal kunne endres etter at objektet er opprettet:
</span><strong>private T value;
public T getValue() { … }
**<span style="color=#980000;">(Dersom X er boolean/Boolean, så brukes gjerne “is” som prefiks istedenfor ”get”).
</span></strong>public void setValue(T value) { … }**</p>

<p><span style="color=#980000;">Med static-modifikatoren vil metodene ikke kunne referere til et bestemt RadioAlphabet-objekt. En kan for så vidt gjøre alfabetet static også, men da vil en bare kunne ha ett globalt alfabet.
En metode kan være </span><strong>static</strong><span style="color=#980000;"> siden den ikke bruker felt eller metoder som er ikke-</span><strong>static</strong><span style="color=#980000;">.</span></p>

<p><span style="color=#980000;">I forhold til innkapsling, hovedgrunnen til å la en konstruktør ta en eller flere parametre : Parametrene til en konstruktør er informasjon som trengs for å gi objektet en gyldig starttilstand, som oftest verdien til felt som må være satt og det ikke finnes noen fornuftig default-verdi.</span></p>

<p><span style="color=#980000;">Java ved gitte forutsetninger vil automatisk opprette en konstruktør for en klasse, slik at instanser av klassen kan opprettes, selv om en ikke eksplisitt har definert en konstruktør for klassen. Betingelsen(e) for at Java skal gjøre dette : Forutsetningen for å automatisk opprette en konstruktør er at den er instansierbare dvs. ikke abstrakt, og det ikke er definert noen andre konstruktører. En slik konstruktør vil være </span><strong>public</strong><span style="color=#980000;"> og ha tom parameterliste.</span></p>

<p><span style="color=#980000;">En annen teknikk for initialisering enn deklarasjon er å bruke en eller flere konstruktører. Dette er metoder med samme navn som klassen som blir implisitt kalt ved bruk av new (med eller uten argumenter). </span><span style="color=#980000;">Fordeler</span><span style="color=#980000;">:
	- en kan skrive mer komplisert kode for initialisering, med f.eks. valg og validering
	- en kan (tvinges til å) oppgi argumenter som kan brukes i initialiseringen
	- konstruktører hjelper en å sikre tilstand ved bruk av innkapsling
</span><span style="color=#980000;">Ulemper</span><span style="color=#980000;">:
	- koden for initialisering blir ofte langt unna feltene den initialiserer
	- det er lett å glemme å initialisere felt</span></p>

<p><span style="color=#980000;">Dette handler om</span><span style="color=#980000;"><a href="https://www.ntnu.no/wiki/display/tdt4100/Innkapsling"> innkapslin&lt;/span&gt;g</a><span style="color=#980000;">, som har to aspekter: 1) sikring av gyldig tilstand og 2) skjuling av implementasjonsdetaljer, så koden lettere kan endres uten at andre klasser påvirkes. Av disse to er aspekt 1) viktigst.</span></span></p>

<p><span style="color=#980000;">Den første teknikken krever mindre kode og er derfor enklere å lese og skrive. Siden en bruker </span><strong>final</strong><span style="color=#980000;">-modifikatoren så sikres aspekt 1), siden verdiene/tilstanden ikke kan endres tross at feltet er </span><strong>public</strong><span style="color=#980000;">. Imidlertid så er det andre aspektet ved innkapsling ikke ivaretatt, siden feltet er eksponert. Derfor er den andre teknikken å foretrekke, som ivaretar begge aspektene.</span></p>

<p><span style="color=#980000;">Objekter som ikke kan endres, kan deles/brukes i flere datastrukturer uten fare for kluss. Hvis delte objekter kan endres, så må en være mer nøye på hva en gjør.</span></p>

<p><span style="color=#980000;">finne passende datastruktur og innkapslingsmetoder. En trenger bare én add-metode, selv om det er vist to har. For å gå gjennom segmentene trenger en både én metode for </span><strong>count/size</strong><span style="color=#980000;"> (ellers vet en ikke når iterasjonen skal stoppe) og én for å hente ut et element.
Det var veldig mange som lurte på formuleringen “gå gjennom dem basert på indeks”, antageligvis fordi det ikke var sagt at dette var </span><em>innkapsling for andre klasser</em><span style="color=#980000;">, ikke til bruk internt i klassen.</span></p>

<h1 id="grensesnittinterface---teorispørsmål">Grensesnitt/Interface - Teorispørsmål</h1>

<ol>
  <li>
    <p><span style="color=#172b4d;">Hvilket nøkkelord i Java brukes for å angi at en klasse implementerer et grensesnitt?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hva er forskjellen på en klasse og et grensesnitt?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Nevn tre bruksområder hvor det er en fordel å bruke grensesnitt.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Kan grensesnitt definere private metoder? </span></p>

    <ol>
      <li><span style="color=#172b4d;">Hvorfor gir/gir ikke dette mening?</span></li>
    </ol>
  </li>
  <li>
    <p><span style="color=#172b4d;">Kan et grensesnitt implementere et annet grensesnitt?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Kan et grensesnitt arve et annet grensesnitt?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hva er forskjellen på å implementere et grensesnitt og å arve fra en annen klasse?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hva er forskjellen på en abstrakt klasse og et grensesnitt?</span></p>

    <ol>
      <li><span style="color=#172b4d;">Hvilke muligheter har man i en abstrakt klasse som man ikke har i et grensesnitt?</span></li>
    </ol>
  </li>
  <li>
    <p><span style="color=#172b4d;">Definer (skriv ned) et grensesnitt etter hukommelsen. </span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Kan et grensesnitt inneholde variabler?</span></p>

    <ol>
      <li><span style="color=#172b4d;">Hva må eventuelt en variabel deklareres som for å være tillatt i et grensesnitt?</span></li>
    </ol>
  </li>
  <li>
    <p><span style="color=#172b4d;">Kan et grensesnitt definere konstruktører?</span></p>
  </li>
</ol>

<p><span style="color=#980000;">Et grensesnitt skal ikke ha konstruktører og statiske metoder. Det er faktisk lov å ha statiske metoder i grensesnitt i Java, men det hører ikke med i objektorientert tenkning.</span></p>

<p><span style="color=#980000;">Dice-grensesnittet </span>*må *<span style="color=#980000;">utvide (extends) Iterable<Integer> &lt;/span&gt;*og kan *<span style="color=#980000;">liste opp metoden(e) fra Iterable. for et grensesnitt kan gjenta metoder fra et grensesnitt det utvider, men må ikke. </span></Integer></span></p>

<h1 id="arv---teorispørsmål">Arv - Teorispørsmål</h1>

<ol>
  <li>
    <p><span style="color=#172b4d;">Hva er forskjellen på en abstrakt klasse og et grensesnitt?</span><span style="color=#172b4d;">
</span><span style="color=#980000;">En abstrakt klasse er en klasse som ikke kan instansieres, enten fordi den er ufullstendig ved at den deklarerer én eller flere abstrakte (tomme) metoder, eller fordi det ikke gir mening. Ingen av de tre klassene bør være abstrakte, siden alle er fullstendige og implementerer en nyttig relasjon.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvilke krav må en subklasse oppfylle for at det skal være naturlig for den å arve fra en superklasse?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvilket nøkkelord brukes for å arve fra en annen klasse i Java?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvor mange klasser kan en subklasse arve fra?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Du har tre klasser: Human, Person og Student. Student arver fra Person, og Person arver fra Human. Du lager et objekt av hver klasse: human, person, student.</span></p>

    <ol>
      <li>
        <p><span style="color=#172b4d;">Har student tilgang til feltene og metodene i Human?</span></p>
      </li>
      <li>
        <p><span style="color=#172b4d;">Hva vil “human instanceof Student” returnere?</span></p>
      </li>
      <li>
        <p><span style="color=#172b4d;">Hva vil “student instanceof Human” returnere?</span></p>
      </li>
    </ol>
  </li>
  <li>
    <p><span style="color=#172b4d;">Når en subklasse arver fra en superklasse, får den tilgang til konstruktørene til superklassen?</span></p>

    <ol>
      <li><span style="color=#172b4d;">Når får den eventuelt (ikke) det?</span></li>
    </ol>
  </li>
  <li>
    <p><span style="color=#172b4d;">Forklar hvordan bruk av protected-felt/metoder fungerer ved arv.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Kan man instansiere en abstrakt klasse?</span><span style="color=#172b4d;">
</span><span style="color=#980000;">2 klasser har en del felles egenskaper, som kan samles i en felles superklasse kalt </span><strong>MenuItem</strong><span style="color=#980000;">:</span><span style="color=#980000;">
Her er poenget å samle det som er felles. Klassen bør være abstract, siden det ikke gir mening å instansere den.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Er det nødvendig å bruke annotasjonen @Override når man redefinerer en arvet metode?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Du har arvet en metode fra en superklasse og redefinert den i din egen klasse. Hvordan kan man bruke metoden som var definert i superklassen?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Du skriver din egen konstruktør i en subklasse, men ønsker å kalle superklassens konstruktør for å slippe å kopiere kode. Hvordan gjør du dette?</span></p>
  </li>
</ol>

<p><span style="color=#980000;">- Når en arver så kan en ikke kun arve de metodene en ønsker, men får alle med på kjøpet. Da vil en være nødt til å redefinere alle en ikke trenger/ønsker at skal være tilgjengelig.</span></p>
<ul>
  <li>&lt;/span&gt;<span style="color=#980000;">Det vil ikke alltid være logisk riktig at klassen skal være </span>**instanceof List<X>**<span style="color=#980000;"></span></X></li>
  <li>&lt;/span&gt;<span style="color=#980000;">(Teknikken kan bare brukes for én slik liste, siden en bare kan arve fra én implementasjonsklasse).</span></li>
</ul>

<p><strong>super()</strong><span style="color=#980000;"> kaller konstruktøren i superklassen og trengs for å sikre at også superklassens konstruktør blir kjørt. Her er super-klassen implisitt Object-klassen. Hvis linja ikke er med, så vil et tilsvarende kall, altså til en konstruktør uten argumenter, bli lagt til av kompilatoren. Derfor kan vi trygt fjerne linja.</span></p>

<p><span style="color=#980000;">Poenget her at siden </span><strong>Course</strong><span style="color=#980000;"> og </span><strong>Meal</strong><span style="color=#980000;"> nå har en felles superklasse, så blir det enklere å ha datastrukturer med begge disse objekttypene i. Dette forenkler både </span><strong>Menu</strong><span style="color=#980000;">- og </span><strong>Table</strong><span style="color=#980000;">-klassene. En blir her bedt om å skrive mye kode på nytt, og siden eksamen var digital, så bør det være greit i praksis. Det er greit å bare skrive de delene som blir endret, til nød forklare endringene med tekst.</span></p>

<p><span style="color=#980000;">Det disse tre implementasjonene har felles er </span><strong>score</strong><span style="color=#980000;">-verdien, så denne kan legges i den abstrakte </span><strong>AbstractScorer</strong><span style="color=#980000;">-klassen, initialiseres ved å kalle </span><strong>super(score)</strong><span style="color=#980000;"> øverst i subklasse-konstruktørene og leses med </span><strong>getScore()</strong><span style="color=#980000;">:</span></p>

<p><span style="color=#980000;">En antar at det finnes ulike klasser for ulike typer fremkomstmidler en kan leie. Hver type skal kunne ha sine egne sett med verdier brukt til prising, f.eks. pris pr. time og pris pr. Tidsforlengelse. Hvordan arvingsmekanismen kan benyttes?</span></p>
<ul>
  <li>Det naturlige er da å lage en abstrakt klasse &lt;/span&gt;<strong>Vehicle</strong><span style="color=#980000;"> som inneholder priselementer (pris per time, forsentbot etc) og gettere/settere (som </span><strong>getHourRate</strong><span style="color=#980000;">, </span><strong>setLocation</strong><span style="color=#980000;"> m.m). Ikke alle av disse trenger å være abstrakte, eksempelvis kan det som har med lokasjon å gjøre være implementert i Vehicle. Alle fremkomstmidler (</span><strong>Bike</strong><span style="color=#980000;">, </span><strong>Hoverboard</strong><span style="color=#980000;"> og slikt) og må så arve denne klassen og kan redefinere metoder for å endre verdiene/logikken som brukes i prisberegningen. Der en i </span><strong>BikeRental</strong><span style="color=#980000;"> (som egentlig burde skifte navn til </span><strong>VehicleRental</strong><span style="color=#980000;">) refererer til </span><strong>Bike</strong><span style="color=#980000;"> må en nå i stedet referere til den abstrakte klassen </span><strong>Vehicle</strong><span style="color=#980000;">.</span></li>
</ul>

<p><span style="color=#980000;">Vi lager en abstrakt klasse basert på Trip og gjør estimateTime abstract:
Så lar vi Trip arve fra denne og implementere estimateTime som over.
Andre varianter (interface) vil gjøre det samme, men implementere estimateTime med annen logikk. Det er strengt tatt ikke nødvendig å ha en abstrakt klasse, en kan alternativt bare arve fra Trip.</span></p>

<p><strong>SimpleTable</strong><span style="color=#980000;"> og </span><strong>CompositeTable</strong><span style="color=#980000;"> blir subklasser av Table, som selv enten blir et grensesnitt eller en abstrakt klasse med i hvertfall </span><strong>getCapacity</strong><span style="color=#980000;">-metoden. De to variantene er vist under. </span><strong>SimpleTable</strong><span style="color=#980000;"> kan ta over det meste av </span><strong>Table</strong><span style="color=#980000;">-koden, evt. arve alt. </span><strong>CompositeTable</strong><span style="color=#980000;"> kapsler inn informasjonen fra </span><strong>mergeTable</strong><span style="color=#980000;"> og bruker de to </span><strong>Table</strong><span style="color=#980000;">-objektene til å beregne kapasiteten. Alternativt kan </span><strong>Table</strong><span style="color=#980000;"> beholde </span><strong>capacity</strong><span style="color=#980000;">-feltet og </span><strong>getCapacity()</strong><span style="color=#980000;">-metoden og de to andre initialiserer </span><strong>capacity</strong><span style="color=#980000;"> med </span><strong>super(…)</strong><span style="color=#980000;">. Vi har her ikke lagt opp til at </span><strong>CompositeTable</strong><span style="color=#980000;">-objekter skal få et løpenummer, men det er greit å la den funksjonaliteten være en del av en abstract </span><strong>Table</strong><span style="color=#980000;">-(super)klasse.</span></p>

<p><span style="color=#980000;">Her er poenget å skille ut det som har med </span><strong>score</strong><span style="color=#980000;"> å gjøre i en abstrakt superklasse, nemlig feltet </span><strong>score</strong><span style="color=#980000;">, (den delen av) konstruktøren som tar inn og setter </span><strong>score</strong><span style="color=#980000;"> og </span><strong>getScore</strong><span style="color=#980000;"> og </span><strong>setScore</strong><span style="color=#980000;">. Dette er viktigst.</span></p>
<ul>
  <li>Hvis en lar den abstrakte superklassen implementere Dice-grensesnittet evt. deklarer en del av Dice sine metoder som abstrakte metoder, så kan enda flere metoder implementeres, f.eks. trenger toString og getValueCount bare getDieCount og getDieValue. En trenger ikke implementere disse, men forklare at det går an og vil være lurt.&lt;/span&gt;</li>
</ul>

<h1 id="delegering---teorispørsmål">Delegering - Teorispørsmål</h1>

<ol>
  <li>
    <p><span style="color=#172b4d;">Forklar forholdet mellom en delegat og en delegerende.</span><span style="color=#172b4d;">
</span><span style="color=#1155cc;"><a href="https://www.ntnu.no/wiki/display/tdt4100/Delegeringsteknikken">Delegeringsteknikke&lt;/span&gt;n</a><span style="color=#980000;"> i praksis, hvor en instans av (en implementasjon av) et grensesnitt bruker en eller flere andre instanser av (implementasjoner av) samme grensesnitt, til å gjøre jobben.</span></span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">I et firma med en Manager og flere Coworkers, hvem er naturlig de(n) delegerende og hvem er delegat(er)? </span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Forklar hvordan det kan være nyttig å benytte grensesnitt i forbindelse med delegering.</span></p>

    <ol>
      <li><span style="color=#172b4d;">Ved å benytte grensesnitt for en delegat-klasse, hvilke fordeler får man?</span></li>
    </ol>
  </li>
  <li>
    <p><span style="color=#172b4d;">Når kan det være smart å benytte delegeringsteknikken fremfor arv?</span></p>
  </li>
</ol>

<p><span style="color=#980000;">Delegering er en teknikk hvor et objekt, videreformidler kall til en “delegat” når det er behov for delegatens ferdigheter. I dette tilfellet er det viktig at TimeSlot-objektene som ligger i delegaten regnes med i logikken. F.eks. må </span><strong>getTimeSlotAt(…)</strong><span style="color=#980000;">-metoden sjekke egne TimeSlot-objekter og delegatens og returnere det tidligste av de to.</span></p>

<p><span style="color=#980000;">I del 2 ble utregning av kostnad ‘hardkodet’ inn i </span><strong>rentBike</strong><span style="color=#980000;">. Hvis man skal støtte utregning av kostnader ved hjelp av delegering, så må man lage et grensesnitt (interface) som inneholder en metode for beregning av pris. I LF har vi laget grensesnittet </span><strong>PricePolicy</strong><span style="color=#980000;">, som blir implementert av klassen </span><strong>DefaultPricePolicy</strong><span style="color=#980000;">. I del 2 ble all beregning gjort i en egen hjelpemetode, </span><strong>computePrice</strong><span style="color=#980000;">. Det er derfor helt greit at grensesnittet inneholder nettopp denne metoden. I </span><strong>BikeRental</strong><span style="color=#980000;"> må en så opprette et </span><strong>DefaultPricePolicy</strong><span style="color=#980000;">-objekt, og kalle dennes </span><strong>computePrice</strong><span style="color=#980000;"> for å beregne pris. Hvis en vil bruke en annen prisingslogikk, så bruker man bare en annen implementasjon.
</span></p>

<p><span style="color=#980000;">en kan også bruke delegering for å tilby </span><em>individuell</em><span style="color=#980000;"> prising (altså pr. </span><strong>Person</strong><span style="color=#980000;">), f.eks. Bonus-ordninger: I 3a ble det lagt opp til delegering av kostnadsberegning, men dette var ikke knyttet til enkeltpersoner. For å implementere individuell prising kan en heller lage et sett med ulike </span><strong>PricePolicy</strong><span style="color=#980000;">, (studenter, barn, voksne etc.) og knyttet disse til </span><strong>Person</strong><span style="color=#980000;">-objektet (med gettere og settere). Når </span><strong>rentBike</strong><span style="color=#980000;"> skal beregne kostnad må en så delegere til </span><strong>Person</strong><span style="color=#980000;">-objektet (som igjen ligger i </span><strong>Bike</strong><span style="color=#980000;">) sin </span><strong>PricePolicy</strong><span style="color=#980000;">.</span></p>

<p><span style="color=#980000;">Delegeringsteknikken er mer fleksibel enn arv, fordi en når som helst kan bytte ut TimeEstimator-objektet og dermed også endre oppførselen til estimateTime-metoden. Arv-mekanismen frigjøres dessuten til andre mer “verdige” formål.</span></p>

<p><span style="color=#980000;">Poenget her er å gjøre som beskrevet i oppgaven, å bruke </span><strong>rel2</strong><span style="color=#980000;"> på resultatet av å bruke </span><strong>rel1</strong><span style="color=#980000;">. Her sjekkes det ikke for duplikater (som det sjelden er behov for med relasjoner av denne typen). Dette er </span><em>delegeringsteknikken</em><span style="color=#980000;"> i praksis, som kjennetegnes ved at et </span><em>delegerende</em><span style="color=#980000;"> objekt, som skal utføre en oppgave, ber en eller flere </span><em>delegater</em><span style="color=#980000;"> om å utføre (omtrent) samme oppgave, for så å kombinere resultatene. Her delegeres det til </span><strong>rel1</strong><span style="color=#980000;"> og </span><strong>rel2</strong><span style="color=#980000;">, som implementerer samme grensesnitt som </span><strong>Relation2</strong><span style="color=#980000;">.</span></p>

<h1 id="observatør-observert-teknikken---teorispørsmål">Observatør-observert-teknikken - Teorispørsmål</h1>

<ol>
  <li>
    <p><span style="color=#172b4d;">På hvilken måte kan observatør-observert-teknikken hjelpe til å holde tilstanden i et program konsistent?</span><span style="color=#172b4d;">
</span><span style="color=#980000;">Observatør-observert-teknikken brukes når en eller flere objekter, her kalt observatører, må holdes konsistent med et annet objekt, her kalt observert, og det observerte objektet sin implementasjon ikke skal være for tett knyttet til observatørenes. Teknikken er basert på at det observerte objektet sier fra til en eller flere observatører om at tilstanden er endret, slik at observatørene kan oppdatere sin tilstand ift. deres regler for konsistens.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Nevn (minst) tre metoder som burde være med i de aller fleste implementasjoner av observatør-observert-teknikken.</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvorfor kan det være lurt å benytte grensesnitt for den observerte parten i et observatør-observert-forhold?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvorfor kan det være lurt å benytte grensesnitt for observatør-parten i et observatør-observert-forhold?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Tenk at en nettside oppdateres jevnlig, og du ønsker å få et varsel til mobilen din hver gang nettsiden oppdateres. Hvilken av partene er den observerte og og hvilken er observatør?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvorfor lønner det seg å bruke observatør-observert-teknikken fremfor å jevnlig sjekke om et objekt har endret tilstand?</span></p>
  </li>
</ol>

<p><span style="color=#980000;">Dette er standard bruk av observatør-observert-teknikken, altså må en ha felt med liste av lyttere, metoder for å legge til og fjerne lyttere og helst en hjelpemetode for å varsle dem.</span></p>

<p><span style="color=#980000;">Observatør-observert-teknikken, lytte til endringer. Lytting med 1) et grensesnitt, 2) liste av lyttere, 3) add/remove-metoder for lyttere, 4) metode til lytterne og 5) kall av metode når endring skjer.</span></p>

<p><span style="color=#980000;">Observerbarhet krever:
	1. at en holder styr på lytterne og
	2. at alle endringsmetoder kaller lytternes lyttermetode.</span></p>

<p><span style="color=#980000;">Observert-observatør-teknikken brukes til å følge med på hvordan tilstanden til objekter endres over tid, typisk for å sikre konsistens med andre objekter, f.eks. et GUI med “indre” objekter. Et objekt er observerbart dersom en kan lese ut alle relevant tilstand og en kan få beskjed (lytte på hendelser) om når og hvordan denne tilstanden endres.
	Det siste spørsmålet er et lurespørsmål: Dice er allerede observerbar! Siden tilstanden ikke kan endres, så trenger en ikke å støtte lyttere. Hvis tilstanden kunne endres, så måtte man 1) definert et lyttergrensesnitt, 2) hatt metoder for å administrere (registrere og avregistrere) lyttere, 3) hatt metode(r) for å sende ut varsler om tilstandsendringer og 4) kalt disse metodene i alle metoder som faktisk endrer tilstanden.</span></p>

<p><span style="color=#980000;">Den generelle teknikken er </span><em>observatør-observert</em><span style="color=#980000;">, som både brukes for å si fra om at tiden går og om at </span><strong>Trip</strong><span style="color=#980000;"> er endret. Tiden håndteres ved å anta at det finnes en </span><strong>Clock</strong><span style="color=#980000;">-klasse, som kan si fra hvert minutt til et sett med lyttere. En kan f.eks. ha grensesnittet </span><strong>ClockListener</strong><span style="color=#980000;"> med </span><strong>minuttPassed()</strong><span style="color=#980000;">-metoden og metodene </span><strong>addClockListener</strong><span style="color=#980000;"> og </span><strong>removeClockListener</strong><span style="color=#980000;">. </span><strong>Trip</strong><span style="color=#980000;"> må gjøres </span><em>observerbar</em><span style="color=#980000;">: 1) en må ha lese-metoder for alle relevante data og 2) en må kunne registrere lyttere (som implementerer et lyttergrensesnitt f.eks. kalt </span><strong>TripChangedListener</strong><span style="color=#980000;">) som får beskjed når objektet endres (f.eks. vha. en metode kalt </span><strong>tripChanged</strong><span style="color=#980000;">).</span></p>

<p><span style="color=#980000;">Hva innebærer observerbarhet? Hvordan en gjør en (egenskap i en) klasse observerbar?</span></p>
<ul>
  <li>Observerbarhet handler om å la et eller flere objekter (observatørene/lytterne) få beskjed om endringer i et annet objekt (den observerte). Observert-klassen må administrere et sett med lyttere (objekter som implementerer et lyttergrensesnitt), vha. felt for Collection av lyttere og add/remove-metoder. Alle steder hvor tilstanden (til egenskapen) endres, må det skytes inn kode som sier fra til lytterne (kall på fire-metode, som går gjennom lytterne).</li>
  <li>Capacity-egenskapen beregnes på bakgrunn av &lt;/span&gt;<strong>tables</strong><span style="color=#980000;">- og </span><strong>seatings</strong><span style="color=#980000;">-listene, og derfor må lytterne varsles hver gang disse endres (av </span><strong>addTable</strong><span style="color=#980000;">, </span><strong>removeTable</strong><span style="color=#980000;">, </span><strong>addSeating</strong><span style="color=#980000;"> og </span><strong>removeSeating</strong><span style="color=#980000;">). Det skilles ikke mellom om kapasiteten øker eller minker, selv om det er økning som </span><strong>GuestManager</strong><span style="color=#980000;"> er interessert i. Lyttere registreres med </span><strong>add</strong><span style="color=#980000;">/</span><strong>removeCapacityListener</strong><span style="color=#980000;">-metoder og en </span><strong>fireCapacityChanged</strong><span style="color=#980000;">-metode, som varsler lytterne (CapacityListener-implementasjoner), kalles av endringsmetodene.</span></li>
</ul>

<p><span style="color=#980000;">Standardteknikken krever et passende lyttergrensesnitt og en liste av lyttere som kalles på passende sted. En bruker gjerne en Collection for å lagre lytterne og add/remove-metoder for å administrere lytterne.</span></p>
<ul>
  <li>LF definerer lyttergrensesnittet &lt;/span&gt;<strong>TreatmentListener</strong><span style="color=#980000;">. Dette grensesnittet har én metode, som kalles idet doktor-pasient-koblingen etableres, altså på tidspunktet det passer å gi beskjed til pasienten om hvilken doktor hen skal gå til. Metoden bør ta inn faktisk pasient, doktor og akuttmottak (</span><strong>TreatmentUnit</strong><span style="color=#980000;">).</span></li>
  <li>Endringer som må gjøres i &lt;/span&gt;<em>den</em><span style="color=#980000;"> </span><em>observerte</em><span style="color=#980000;">, </span><strong>TreatmentUnit</strong><span style="color=#980000;">, er at alle lytterne lagres i en </span><strong>private</strong><span style="color=#980000;"> </span><strong>Collection</strong><span style="color=#980000;"> av type </span><strong>TreatmentListener</strong><span style="color=#980000;">, og at den legger inn relevante </span><strong>public add/remove</strong><span style="color=#980000;"> til denne. I tillegg defineres hjelpemetoden </span><strong>fireTreatmentStarted</strong><span style="color=#980000;">, som kalles rett etter at </span><strong>setPatient</strong><span style="color=#980000;"> har etablert en ny doktor-pasient-kobling (i både </span><strong>startTreatment(Doctor)</strong><span style="color=#980000;"> og </span><strong>startTreatment(Patient)</strong><span style="color=#980000;">).</span></li>
</ul>

<h1 id="typer---teorispørsmål">Typer - Teorispørsmål</h1>

<ol>
  <li>**Collection<String> strings = new ArrayList<String>()**<span style="color=#172b4d;">
a) Hva er sammenhengen med typen deklarert på venstre-side og typen deklarert på høyre-side?</span><span style="color=#172b4d;">
</span><span style="color=#980000;">Hvordan påvirker </span>**String**<span style="color=#980000;">-spesialiseringen (altså det som står mellom </span>**&lt; &gt;**<span style="color=#980000;">) bruken av </span>**strings**<span style="color=#980000;">-variabelen?
</span></String></String>    <ul>
      <li>Typen på høyresiden må være den samme eller en subklasse (inkl. implementasjonsklasse, som her) av typen på venstresiden. Spesialiseringen må være den samme. &lt;/span&gt;<strong>String</strong><span style="color=#980000;">-spesialiseringen påvirker parametertyper og returtyper for </span><strong>Collection</strong><span style="color=#980000;">- og </span><strong>ArrayList</strong><span style="color=#980000;">-metodene. F.eks. vil </span><strong>get</strong><span style="color=#980000;"> returnere </span><strong>String</strong><span style="color=#980000;"> og </span><strong>add</strong><span style="color=#980000;"> og </span><strong>set</strong><span style="color=#980000;">-metodene vil ta en </span><strong>String</strong><span style="color=#980000;"> som parameter.</span><span style="color=#172b4d;">
b) Hvordan påvirker det videre programmering at det står <String>? &lt;/span&gt;</String></span></li>
    </ul>
  </li>
  <li>
    <p><span style="color=#172b4d;"> Hva er casting? </span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">a) Hva er forskjellen på int og Integer?
b) Gi et eksempel på når en må bruke Integer. </span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hva er typen til følgende uttrykk? 
a) “Java” + “Gøy”;  </span><span style="color=#172b4d;">// String + String = String</span><span style="color=#172b4d;">
b) 1/2;  /</span><span style="color=#172b4d;">/ int / int = int</span><span style="color=#172b4d;">
c) (“J”+”ava”).charAt(2);  //</span><span style="color=#172b4d;"> char</span></p>
  </li>
  <li><span style="color=#172b4d;">Public Eksamen(String besvarelser…){} 
Hvor mange String-objekter kan sendes inn i denne konstruktøren?  </span></li>
</ol>

<p><span style="color=#980000;">Man må </span><span style="color=#980000;">deklarere </span><em>typen</em><span style="color=#980000;"> til alle felt, variabler og parametre (i motsetning f.eks. Python, Javascript og Matlab). De viktigste fordelene er at </span><span style="color=#980000;">det </span><span style="color=#980000;">blir lettere å:</span></p>

<ol>
  <li>
    <p><span style="color=#980000;">oppdage/hindre feil bruk av verdier (for verktøy, kompilator og programmerer)</span></p>
  </li>
  <li>
    <p><span style="color=#980000;">tilby hjelp til kodingen, f.eks. foreslå metoder</span></p>
  </li>
  <li>
    <p><span style="color=#980000;">kompilere til effektiv kode</span><span style="color=#980000;"> </span></p>
  </li>
</ol>

<p><span style="color=#980000;">At metoder i en klasse kan ha samme navn kalles “overloading”. For å avgjøre hvilken som skal kalles, brukes de deklarerte typene til argumentene (ikke returverdien). Merk at dette er noe annet enn polymorfi, som handler om at subklasser kan ha ulike implementasjoner av metoder definert i en felles superklasse.</span></p>

<p>&lt;/span&gt;<span style="color=#980000;">Hensikten med å definere en </span><strong>toString()</strong><span style="color=#980000;">-metode er at </span><strong>toString()</strong><span style="color=#980000;">-metoden brukes implisitt når Java lager String-objekter av instanser ifm. bruk av </span><strong>+</strong><span style="color=#980000;"> og IO og sikrer at tilstanden til instanser blir presentert på en nyttig måte.</span></p>

<p><span style="color=#980000;">
Hvordan er klassen kodet så det forklarende ordet/navnet vises ved utskrift, f.eks. med </span><strong>System.out.println(…)</strong><span style="color=#980000;">? Ved utskrift så brukes implisitt </span><strong>toString()</strong><span style="color=#980000;">-metoden, som er implementert og returnerer </span><strong>label</strong><span style="color=#980000;">.</span></p>

<p><span style="color=#980000;">Et funksjonelt grensesnitt har bare én abstrakt metode, og resultatet av å utføre metoden skal alltid være det samme for samme argumenter. Dette gjør at man kan tenke på implementasjonen som en matematisk funksjon. Det er også et poeng (men underordnet) at grensensittet er ment å være den </span><em>primære</em><span style="color=#980000;"> funksjonen til klassen som implementerer den. Ellers gir det ikke så mye mening å bruke anonyme klasser/lambda-uttrykk til å implementere grensesnittet. Et eksempel på dette er </span><strong>Comparator</strong><span style="color=#980000;">, som kun implementeres for å sammenligne argumentene. </span><strong>Comparable</strong><span style="color=#980000;">-derimot, implementeres av dataklasser og er derfor en sekundær funksjon, som det ikke er noe poeng å implementere som primærfunksjon.</span></p>

<p><strong>DiceScorer</strong><span style="color=#980000;">-grensesnittet er funksjonelt fordi det 1) har kun én abstrakt metode og 2) er ment å være primærtfunksjonen til klassen som implementerer den.</span></p>

<p><span style="color=#980000;">Funksjonelle grensesnitt har bare én metode (krav 1), og den metoden er </span><em>funksjonell</em><span style="color=#980000;"> fordi den for samme input(-parametre) alltid gir samme output(-verdi). En annen måte å si det siste på er at den ikke har intern tilstand som påvirker oppførselen og som kan endres. Det er også vanlig å tenke på grensesnitt-metoden som klassens </span><em>hovedfunksjon</em><span style="color=#980000;">.</span></p>

<p><strong>CapacityListener</strong><span style="color=#980000;">-grensesnitt er (teknisk sett) funksjonelt, siden det bare har én (abstrakt) metode (og kan derfor implementeres med lambda-syntaksen). Dette kreves i et svar som får poeng i det hele tatt. I tillegg bør andre argumenter (for at grensesnittet ikke er funksjonelt) trekkes inn, f.eks. at metoden typisk ikke er implementasjonens primære funksjon og at en ikke tenker på den som en matematisk funksjon som kun er avhengig av argumentene.</span></p>

<p><span style="color=#980000;">Hjelpemetode </span><strong>tokenize</strong><span style="color=#980000;">, som kan være nyttig ved innlesing og som kan antas ferdig implementert. Modifikatorer?
En slik hjelpemetode bør for det første være markert som </span><strong>private</strong><span style="color=#980000;">, siden det ikke er naturlig at dette er en tjeneste som tilbys andre klasser. For det andre bør den være markert som </span><strong>static</strong><span style="color=#980000;">, siden den ikke bruker (leser eller endrer) tilstanden til noe </span><strong>Family</strong><span style="color=#980000;">-objekt. Eneste grunn til at den ikke skal være </span><strong>static</strong><span style="color=#980000;">, er hvis en subklasse av </span><strong>Family</strong><span style="color=#980000;"> har behov for å redefinere den, og det er ikke aktuelt her.</span></p>

<p><span style="color=#980000;">Her er poenget at en trenger en </span><em>global</em><span style="color=#980000;"> teller, som en får til i Java ved bruk av </span><strong>static</strong><span style="color=#980000;">. Denne må brukes og økes i </span><strong>Table</strong><span style="color=#980000;"> sin konstruktør.</span></p>

<h1 id="testing---teorispørsmål">Testing - Teorispørsmål</h1>

<ol>
  <li>
    <p><span style="color=#172b4d;">Hvilke tre “faser” går man gjennom under kjøring av en JUnit-test?</span></p>

    <ol>
      <li><span style="color=#172b4d;">Hva må de ulike metodene i hver “fase” hete?</span></li>
    </ol>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hvor mange test- metoder kan en JUnit-test inneholde?</span></p>
  </li>
  <li>
    <p><span style="color=#172b4d;">Hva er meningen med testing av programmer på enhetsnivå (Slik JUnit gjør)?</span></p>
  </li>
</ol>

<p><span style="color=#980000;">Den </span><em>generelle</em><span style="color=#980000;"> testeteknikken som JUnit-testing (og JExercise) baserer seg på er å rigge opp objekter med en før-tilstand, endre tilstanden og sammenligne med forventet etter-tilstand. Noen ganger er det ingen før- og etter-tilstand, da en kun sjekker et selvstendig metodekall, dvs. sammenligner returverdi med fasiten.</span></p>
<ul>
  <li>bruk av &lt;/span&gt;<strong>assertTrue</strong><span style="color=#980000;"> og </span><strong>==</strong><span style="color=#980000;"> og </span>**ikke assertEquals **<span style="color=#980000;">for å sjekke for identisk likhet.</span></li>
</ul>

<p><span style="color=#980000;">For å teste iterasjon med foreach-løkker, må vi bruke metoden som en slik løkke (implisitt) bruker, nemlig </span><strong>iterator()</strong><span style="color=#980000;">-metoden og </span><strong>Iterator</strong><span style="color=#980000;">-objektet som denne returnerer. Her brukes objektene som er rigget opp i </span><strong>setUp</strong><span style="color=#980000;">-metoden.</span></p>

<p><span style="color=#980000;">hvorfor det er mer komplisert å teste </span><strong>rentBike</strong><span style="color=#980000;"> og </span><strong>returnBike</strong><span style="color=#980000;"> enn å teste </span><strong>getRentedBikes</strong><span style="color=#980000;">. Hvilke aspekter ved disse metodene er det som gjør det mer komplisert?</span></p>
<ul>
  <li>&lt;/span&gt;<strong>getRentedBikes</strong><span style="color=#980000;"> kan testes ved å sjekke bare returverdier, etter å ha rigget opp diverse objekter, siden metoden ikke har </span><em>side-effekter</em><span style="color=#980000;">. Effekten av </span><strong>rentBike</strong><span style="color=#980000;"> og </span><strong>returnBike</strong><span style="color=#980000;"> er derimot endring av diverse datastrukturer, så disse må sjekkes etterpå.</span></li>
</ul>

<h1 id="unntakexception">Unntak/Exception</h1>

<p><span style="color=#980000;">I metoder som endrer (en verdi i) et objekt, så bør argumenter valideres. Dette må skje før selve endringen og i tilfelle ugyldig(e) verdier så kastes et unntak av typen </span><strong>IllegalArgumentException(…)</strong><span style="color=#980000;">.</span></p>

<p><span style="color=#980000;">En såkalt </span><em>checked exception</em><span style="color=#980000;"> er en subklasse av Exception som ikke samtidig er en subklasse av RuntimeException. En slik Exception må deklareres vha. </span><strong>throws</strong><span style="color=#980000;"> og den kallende metoden må enten håndtere unntaket med </span><strong>try</strong><span style="color=#980000;">/</span><strong>catch</strong><span style="color=#980000;"> eller deklarere det med </span><strong>throw</strong><span style="color=#980000;">s.</span></p>

<p><span style="color=#980000;">Checked exception : en </span><strong>Exception</strong><span style="color=#980000;"> som ikke er en </span><strong>RuntimeException</strong><span style="color=#980000;"> er en </span><em>checked</em><span style="color=#980000;"> exception. En slik unntakstype krever enten try/catch eller en </span><strong>throws</strong><span style="color=#980000;">-deklarasjon for å unngå kompileringsfeil.</span></p>

<p><span style="color=#980000;">Metoder som sjekker argumentene sine før de utfører evt. endringer på objektet kalles </span><em>validering</em><span style="color=#980000;"> (og er en viktig del av innkapsling). Det er lurt å skille ut valideringen i en egen metode som kalles fra endringsmetodene. Metoden kan være </span><strong>protected</strong><span style="color=#980000;">, så subklasser kan redefinere og gjenbruke valideringslogikken. Det er vanligst å bruke en såkalt </span><em>unchecked exception</em><span style="color=#980000;"> (usjekket unntak), som </span><strong>IllegalArgumentException</strong><span style="color=#980000;">.</span></p>

<p><strong>throws</strong><span style="color=#980000;">-deklarasjonen forteller leseren av koden at konstruktørene kan utløse unntak. Siden unntakene er en subklasse av </span><strong>RuntimeException</strong><span style="color=#980000;"> og dermed ikke </span><em>checked</em><span style="color=#980000;">, så er det ikke nødvendige.</span></p>

<h1 id="ulike-grensesnitt-typer">Ulike grensesnitt typer</h1>

<p>Standard funksjonelle grensesnitt, inkl. **Predicate<T>**, **Consumer<T>**, **Supplier<T>**, **Function&lt;T, R&gt;**, **BiFunction&lt;T1, T2, R&gt;**, **BinaryOperator<T>** og **UnaryOperator<T>**</T></T></T></T></T></p>

<p><span style="color=#980000;">Grensesnitt som </span><strong>Predicate</strong><span style="color=#980000;"> er et såkalt </span><em>funksjonelt</em><span style="color=#980000;"> grensesnitt, siden det har én metode som (er ment som å) oppfører seg som en matematisk funksjon.</span></p>

<p><span style="color=#980000;">Metoden deklareres som </span>**Collection<Person> getMatchingPersons(Collection<Person> persons, Predicate<Person> test)**<span style="color=#980000;">. Koden kan skrives på (minst) to måter, enten som en én-linjer med </span>**Stream**<span style="color=#980000;">-teknikken eller med en løkke som tester og legger til en resultat-liste. Kallet gjøres enklest med lambda-notasjonen:
</span>**getMatchingPersons(persons, p -&gt; p.getGender() == ’M’ &amp;&amp; p.getAge() == 18)**</Person></Person></Person></p>

<p>Collection-rammeverket** (Collection<T>-, List<T>-, Set<T>, Map&lt;K, V&gt;-, Iterator<T>- og Iterable<T>-**grensesnittene og** ArrayList<T>- og HashMap&lt;K, V&gt;-klassene)**, inkludert bruk av **&lt;&gt; **i deklarasjoner, såkalte generics
<span style="color=#980000;">Hvis en klasse implementerer </span>**Iterable**<span style="color=#980000;"> så kan en bruke en instans av klassen på høyresiden av :-tegnet i en for-each-løkka, og iterere over alle verdier "inni" objektet. Her betyr det at vi kan skrive ... </span>**for (double v : values) { ... }**</T></T></T></T></T></T></p>

<p><span style="color=#980000;">Typen bør være et grensesnitt fra </span><strong>Collection</strong><span style="color=#980000;">-rammeverket, enten </span><strong>Collection</strong><span style="color=#980000;"> eller </span><strong>List</strong><span style="color=#980000;">, som er spesialisert til element-typen </span><strong>Course</strong><span style="color=#980000;">. Her brukes </span><strong>Collection</strong><span style="color=#980000;">, fordi en ikke trenger andre metoder enn den deklarerer.</span></p>

<p><span style="color=#980000;">Her er poenget å velge en type som passer til hvordan feltet brukes og verdien den blir tilordnet. Verdien som tilordnes er av typen </span>**List<Course>**<span style="color=#980000;">, så typen må enten være </span>**List**<span style="color=#980000;"> eller en av dens superklasser, som er </span>**Collection**<span style="color=#980000;"> og </span>**Iterable**<span style="color=#980000;">. Hvis vi bare trenger metodene i </span>**Collection**<span style="color=#980000;">, som </span>**List**<span style="color=#980000;"> arver fra, så er det bedre å bruke </span>**Collection**<span style="color=#980000;"> i deklarasjonen.</span></Course></p>

<p><span style="color=#980000;">For å kunne iterere med et </span><strong>Meal</strong><span style="color=#980000;">-objekt bak kolonet i en </span><strong>for</strong><span style="color=#980000;">-løkke, så må </span><strong>Meal</strong><span style="color=#980000;">-klassen implementere </span>**Iterable<Course>**<span style="color=#980000;"> og derfor ha en </span>**iterator()**<span style="color=#980000;">-metode som returnerer </span>**Iterator<Course>**<span style="color=#980000;">.</span></Course></Course></p>

<p><span style="color=#980000;">Her er poenget å skjønne hvordan tabeller virker (opprettes, leses fra og skrives til) og logikken bak </span><strong>valueCounters</strong><span style="color=#980000;">-feltet, samt hvordan iterere med </span><strong>Iterator</strong><span style="color=#980000;"> (</span><strong>hasNext()</strong><span style="color=#980000;"> og </span><strong>next()</strong><span style="color=#980000;">) og </span><strong>Iterable</strong><span style="color=#980000;"> (</span><strong>iterator()</strong><span style="color=#980000;">).</span></p>

<p><span style="color=#980000;">En kan lage en egen klasse som kombinerer mobilnummer og antall minutter i forkant de skal få varsel, eller bruke en </span><strong>Map&lt;String, Integer&gt;</strong><span style="color=#980000;">.</span></p>

<p><span style="color=#980000;">Hvis en klasse implementerer </span><strong>Iterable</strong><span style="color=#980000;">, så kan referanser til denne klassen brukes på høyresiden av kolonet i en for-each-løkke, f.eks. for (Person child : person). Se også </span><strong>getChildren</strong><span style="color=#980000;">-koden over.
Et (litt mindre relevant, og ikke påkrevd) alternativ er </span>**Iterable.forEach(Consumer<Person>)**<span style="color=#980000;">. Dette er en såkalt </span>**default**<span style="color=#980000;">-metode (kom ikke frem i vedlegget) som en får gratis når en implementerer </span>**Iterable**<span style="color=#980000;">.</span></Person></p>

<p><span style="color=#980000;">Forklar med tekst og kode sammenhengen mellom for-each-syntaksen, altså den på formen for (<type> <var> : <uttrykk>) ..., og &lt;/span&gt;**Iterable**<span style="color=#980000;">- og </span>**Iterator**<span style="color=#980000;">-grensesnittene.</span></uttrykk></var></type></span></p>
<ul>
  <li>Den vanlige måten å gå gjennom en liste med elementer er med kode som den under til venstre. Dette kalles en &lt;/span&gt;<strong>for-each</strong><span style="color=#980000;">-løkke, fordi den går gjennom hvert element i lista. Dette er egentlig spesial-syntaks for iterator-basert iterasjon, det er bare det at du aldri ser iteratoren. Funksjonelt sett er </span><strong>for-each</strong><span style="color=#980000;">-løkka til venstre ekvivalent med den </span><strong>Iterator</strong><span style="color=#980000;">-baserte løkka under til høyre. Det er egentlig en smaksak hvilken en bruker, men den venstre varianten er å foretrekke fordi den både er enklere å skrive og lese.</span></li>
  <li>Hvis en tenker over det, så er det nettopp &lt;/span&gt;<strong>iterator()</strong><span style="color=#980000;">-metoden, som er nøkkelen til at </span><strong>for-each</strong><span style="color=#980000;">-løkka virker. Det holder at </span><strong>stringListe</strong><span style="color=#980000;"> i kode-eksemplet har en slik metode, for at den skal kunne “omskrives” til koden til høyre som den tilsvarer. Denne koblingen mellom </span><strong>for-each</strong><span style="color=#980000;">-løkka og </span><strong>iterator()</strong><span style="color=#980000;">-metoden er ikke tilfeldig, og for å gjøre koblingen eksplisitt og mulig å utnytte for klasser utenfor Collection-rammeverket, så er </span><strong>iterator()</strong><span style="color=#980000;">-metoden definert i et eget grensesnitt ved navn </span><strong>Iterable</strong><span style="color=#980000;"> (i </span><strong>java.lang</strong><span style="color=#980000;">-pakken, så en slipper egen import-setning). Det er altså fordi en </span><strong>ArrayList</strong><span style="color=#980000;"> implementerer </span><strong>Iterable</strong><span style="color=#980000;"> at en </span><strong>for-each</strong><span style="color=#980000;">-løkke med en </span><strong>ArrayList</strong><span style="color=#980000;"> virker! Og </span><strong>ArrayList</strong><span style="color=#980000;"> implementerer </span><strong>Iterable</strong><span style="color=#980000;"> fordi den implementerer </span><strong>List</strong><span style="color=#980000;">, og </span><strong>List</strong><span style="color=#980000;"> utvider </span><strong>Collection</strong><span style="color=#980000;"> som utvider </span><strong>Iterable</strong><span style="color=#980000;">. Denne koblingen mellom </span><strong>ArrayList</strong><span style="color=#980000;"> og </span><strong>Iterable</strong><span style="color=#980000;"> er illustrert under med et klassediagram:</span></li>
</ul>

<p>sortering med** Comparable<T> **og** Comparator<T>**</T></T></p>

<p><span style="color=#980000;">Ved å implementere </span><strong>Comparable</strong><span style="color=#980000;">-grensesnittet så kan </span><strong>Value</strong><span style="color=#980000;">-objekter sorteres vha. Java sine innebygde sort-metoder.</span></p>

<p><span style="color=#980000;">Dersom </span><strong>Course</strong><span style="color=#980000;">-klassen implementerer </span><strong>Comparable</strong><span style="color=#980000;">, dvs. sammenligning med et annet </span><strong>Course</strong><span style="color=#980000;">-objekt, så kan </span><strong>Collections.sort</strong><span style="color=#980000;">- og </span><strong>List.sort</strong><span style="color=#980000;">-metodene brukes til sortering av </span><strong>Course</strong><span style="color=#980000;">-objekter.</span></p>

<p><strong>Exam</strong><span style="color=#980000;">-objekter skal også kunne sorteres, men på </span><strong>to måter</strong><span style="color=#980000;">! Hvordan begge sorteringene kan støttes og skriv nødvendig kode : I tillegg til </span><strong>Comparable</strong><span style="color=#980000;">, som bygger sorteringsrekkefølgen inn i klassen selv, så kan en implementere en </span>**Comparator<Exam>**<span style="color=#980000;">, som er en annen klasse som sammenligne to </span>**Exam**<span style="color=#980000;">-objekter:</span></Exam></p>

<p><strong>Table</strong><span style="color=#980000;"> må implementere </span><strong>Comparable&lt;Table&gt;</strong><span style="color=#980000;"> for at </span><strong>sort</strong><span style="color=#980000;">-metoden skal kunne brukes og virke. Alternativt kan man lage en (implementasjon av) </span><strong>Comparator&lt;Table&gt;</strong><span style="color=#980000;">, f.eks. med </span><strong>(t1,t2) -&gt; t1.getCapacity() – t2.other.getCapacity()</strong><span style="color=#980000;">.</span></p>

<p>IO med byte- og tegnstrømmer <strong>(InputStream/OutputStream **og</strong> Reader/Writer **med subklasser) og filer</p>

<ul>
  <li>
    <p><strong>InputStream</strong><span style="color=#980000;">-/</span><strong>OutputStream</strong><span style="color=#980000;">-klassene håndterer </span><strong>byte</strong><span style="color=#980000;">-verdier, mens </span><strong>Reader</strong><span style="color=#980000;">-/</span><strong>Writer</strong><span style="color=#980000;">-klassene håndterer char-verdier (dvs. implementerer koding av tegn til/fra bytes iht. Unicode-regler).</span></p>
  </li>
  <li>
    <p><span style="color=#980000;">Input/output-metoder kaster ofte </span><strong>IOException</strong><span style="color=#980000;">, som er en såkalt “checked exception”. Slike brukes gjerne for feil som er utenfor vår kontroll. Disse krever at kode må fange dem opp med </span><strong>try/catch</strong><span style="color=#980000;"> eller deklarere med </span><strong>throws</strong><span style="color=#980000;"> at de kastes videre.</span></p>
  </li>
  <li>
    <p><span style="color=#980000;">Strømmer bruker gjerne ressurser utenfor Java og </span><strong>close()</strong><span style="color=#980000;">-metoden sikrer at Java samhandler riktig med disse, f.eks. frigjør dem. For å sikre at dette alltid skjer, er det vanlig å ha </span><strong>close()</strong><span style="color=#980000;">-kallet i en </span><strong>try/finally</strong><span style="color=#980000;">-blokk.</span></p>
  </li>
</ul>

<h1 id="streams">Streams</h1>

<p><span style="color=#980000;">return allBikes.stream().filter(bike -&gt; bike.getRenter() == null &amp;&amp; bike.getLocation().distance(location) &lt;= distance).count();</span></p>

<p><span style="color=#980000;">return allBikes.stream().filter(bike -&gt; bike.getRenter() != null).collect(Collectors.toList());</span></p>

<p><span style="color=#980000;">getRentedBikes().stream().filter(bike -&gt; getStationNearby(bike, 30.0) != null).collect(Collectors.toList());</span></p>

<p><span style="color=#980000;">diceCol.stream().map(Dice::getScore).reduce(0, (n1, n2) -&gt; n1 + n2)</span></p>

<p><span style="color=#980000;">diceCol.stream().mapToInt(Dice::getScore).sum()</span></p>

<h1 id="inputoutput-io">Input/Output (IO)</h1>

<p><span style="color=#980000;">Det viktigste med </span><strong>save</strong><span style="color=#980000;">-metoden er at den først skriver ut alle linjer av type 1, altså den person-informasjonen som er nødvendig for å </span><strong>lage</strong><span style="color=#980000;"> Person-objektene før foreldre-barn-koblingen etableres. Vi velger å lage en </span><strong>PrintWriter</strong><span style="color=#980000;"> rundt </span><strong>OutputStream</strong><span style="color=#980000;">-en vi får inn, for å muliggjøre bruke av </span><strong>print</strong><span style="color=#980000;"> og </span><strong>println</strong><span style="color=#980000;">. Vi kunne brukt en </span><strong>PrintStream</strong><span style="color=#980000;">, men en </span><strong>Writer</strong><span style="color=#980000;"> anbefales jo for tekst (trekker ikke for bruk av </span><strong>PrintStream</strong><span style="color=#980000;">). Så skrives alle linjene av type 2 ut. Derfor blir det to iterasjoner over alle medlemmene. Navn får anførselstegn (“) rundt (merk måten ” inkluderes i en String). Her sjekkes det om en person har barn (kan gjøre på mange måter), så det ikke blir linjer med en forelder, men det er strengt tatt ikke definert som et krav (det står ”sequence of names”, og en sekvens kan jo ha bare ett element). Hvis en har linjer med bare én forelder, så er det viktig at load-metoden håndterer det riktig. Det er vanlig at den som setter opp en </span><strong>OutputStream</strong><span style="color=#980000;"> også lukker den, og derfor avslutter vi </span><em>ikke</em><span style="color=#980000;"> med </span><strong>pw.close()</strong><span style="color=#980000;">. Vi avslutter imidlertid med </span><strong>pw.flush()</strong><span style="color=#980000;"> for å sikre at all vår output sendes ut med en gang (trekker ikke for manglende bruk av </span><strong>close()</strong><span style="color=#980000;">/</span><strong>flush()</strong><span style="color=#980000;">).</span></p>

<p><strong>load</strong><span style="color=#980000;">-metoden klassifiserer hver linje som en av de tre typene ved å først sjekke om den er tom eller starter med # (type 3) og så sjekker om første token i en linje er en gyldig </span><strong>Gender</strong><span style="color=#980000;"> (type 1). Ellers er den av type 2. Her gjøres det ingen sjekk på om formatet er korrekt, f.eks. om et barn i en linje av type 2 faktisk er registrert som familiemedlem. Det er kanskje litt uklart hvorvidt og evt. hvordan </span><strong>tokenize</strong><span style="color=#980000;"> håndterer </span><strong>#</strong><span style="color=#980000;">, så det er greit at den brukes før en sjekker for linjer av type 3.</span></p>

<p><span style="color=#980000;">Unntak håndteres ikke av metodene, så de må deklareres med </span><strong>throws</strong><span style="color=#980000;">. Det er naturlig å bruke </span><strong>IOException</strong><span style="color=#980000;">, for den utløses ved bruk av </span><strong>InputStream</strong><span style="color=#980000;"> og </span><strong>OutputStream</strong><span style="color=#980000;">. En kunne brukt </span><strong>Exception</strong><span style="color=#980000;"> or å markere (at vi er klar over) at det er mye som kan gå galt, men det anbefales å bruke den mest spesifikke typen. Vi kunne fanget opp og ignorert unntak, men det kan lett maskere feil vi ønsker å avdekke.</span></p>

<p><strong>public void save(OutputStream out) throws IOException {</strong></p>

<p><strong>PrintWriter pw = new PrintWriter(out);</strong></p>

<p><strong>…</strong></p>

<p><strong>pw.flush()</strong></p>

<p><strong>}
public void load(InputStream in) throws IOException {</strong></p>

<p><strong>Scanner scanner = new Scanner(in);</strong></p>

<p><strong>…</strong></p>

<p><strong>scanner.close();</strong></p>

<p><strong>}</strong></p>

<h1 id="fxml">FXML</h1>

<p><span style="color=#980000;">Av FXML-koden kan en lese at det grafiske grensesnittet (appen) knyttes til </span><strong>BikeRental</strong><span style="color=#980000;"> ved hjelp av klassen </span><strong>BikeRentalController</strong><span style="color=#980000;">. Dette er i tråd med navnekonvensjonene brukt i tidligere eksamener. Det refereres til to tekstfelt som en i koden kobler seg til med henholdsvis  @FXML private TextField </span><strong>fromInput</strong><span style="color=#980000;"> og </span><strong>toInput</strong><span style="color=#980000;">. Likeledes må en lage tre metoder (@FXML private void </span><strong>plus1HourAction</strong><span style="color=#980000;">, </span><strong>minus1HourAction</strong><span style="color=#980000;"> og </span><strong>rentAction</strong><span style="color=#980000;">) som kalles når knappene i grensesnittet trykkes inn.</span></p>

<p><span style="color=#980000;">Her er vi mest opptatt av:
	- @FXML-annotasjonene
	- riktig type og navn for variablene og metoden
	- at en henter input fra </span><strong>dieCountInput</strong><span style="color=#980000;"> og setter output med </span><strong>diceOutput</strong></p>

<h1 id="diagrammer">Diagrammer</h1>

<p>Grovt sett beskriver diagrammer to ulike aspekter ved et program:</p>

<ul>
  <li>
    <p>Tilstand/oppførsel ved kjøretid, altså hva som skjer når programmet kjøres, f.eks. tilstanden til objektstrukturer. Eksempler er **<a href="https://www.ntnu.no/wiki/display/tdt4100/Objekttilstandsdiagrammer">Objektdiagramme<strong>r](https://www.ntnu.no/wiki/display/tdt4100/Objektdiagrammer), **[Objekttilstandsdiagramme</strong>r</a> og **<a href="https://www.ntnu.no/wiki/display/tdt4100/Sekvensdiagrammer">Sekvensdiagramme**r</a>.</p>
  </li>
  <li>
    <p>Design, altså hvordan programkoden er strukturert, f.eks. hvilke klasser som finnes og hvordan de henger sammen. **<a href="https://www.ntnu.no/wiki/display/tdt4100/Klassediagrammer">Klassediagramme**r</a> er et eksempel.</p>
  </li>
</ul>

<p>PLANTUML</p>

<ul>
  <li>Hide circle : hides class/interface/abstract icon</li>
</ul>

<p><span style="color=#980000;">De ulike diagramdelene, altså boksene, strekene/pilene og tegnene (ord, tall og <em>):
Diagrammet er omtrent som et klassediagram, så boksene tilsvarer klasser. Navnet øverst en boks er klassenavnet, mens de andre er egenskaper, dvs. data, som instansene vil ha. Strekene er assosiasjoner (eller relasjoner), som sier noe om hvordan instanser kan kobles sammen. Tallene på enden av strekene angir hvor mange koblinger en instans kan ha (</em> betyr ubegrenset), såkalt </span><em>multiplisitet</em><span style="color=#980000;">. Pilene sier noe om i hvilken retning en kan følge en kobling, ingen betyr begge retninger, mens én pil betyr bare i den retningen.
Egenskapene og assosiasjonene blir typisk til felt med type som passer til multiplisiteten. En må velge hvordan dataene skal </span><em>kapsles inn</em><span style="color=#980000;">, altså konstruktører med parametre, gettere og settere, og evt. add- og remove-metoder og andre metoder.</span></p>

<p><strong>O</strong><strong>bjektdiagrammer (objekter med tilstand og koblinger)</strong></p>

<p>er en diagramtype som viser tilstanden til et program, ved å illustrere “snapshots” av objektstrukturer.</p>

<p>Hva er forskjellen (hensikt og innhold) mellom <em>objektdiagrammer *og *objekttilstandsdiagrammer</em>?</p>

<p><span style="color=#980000;">Et </span><em>objektdiagram</em><span style="color=#980000;"> viser oppbygning av og koblinger mellom objekter/instanser, og brukes for å illustrere tilstanden til (eller en mulig tilstand til) et program. Et </span><em>objekttilstandsdiagram</em><span style="color=#980000;"> viser hvordan slike strukturer endres over tid, ved kall av metoder (typisk endringsmetoder), og brukes til å illustrere (mulig) objektoppførsel og utviklingen av tilstanden til et program.</span></p>

<p><strong>O</strong><strong>bjekttilstandsdiagrammer</strong></p>

<p>Hvis en tenker på objektdiagrammer som tilstander og kobler dem sammen med transisjoner, så får en objekttilstandsdiagram, som viser hvordan objektstrukturer utvikler seg over tid.</p>

<p><span style="color=#980000;">Objekttilstandsdiagrammer brukes til å beskrive oppførselen til et objekt. Viktig fordel og ulempe/begrensning.</span></p>

<ul>
  <li>
    <p><strong>Fordeler</strong><span style="color=#980000;">: Eksempel på forløp kan være enklere å forstå enn en komplett definisjon i form av regler (invarianter). Diagrammer kan være mer intuitive enn tekst. Det er lett å skrive test-kode basert på diagrammet.</span></p>
  </li>
  <li>
    <p><strong>Ulemper</strong><span style="color=#980000;">: Diagrammene blir lett store, hvis de skal dekke alle relevante tilfeller. Det er kun i enkle tilfeller en kan beskrive oppførselen komplett.</span></p>
  </li>
</ul>

<p><img src="image_0.png" alt="image alt text" /></p>

<p><strong>S</strong><strong>ekvensdiagrammer</strong></p>

<p>Interaksjonsdiagrammer viser hvordan objekter i en objektstruktur bruker hverandre, dvs. kaller hverandres metoder. Det finnes to varianter: samhandlingsdiagrammer utvider objektdiagrammer med visning av (sekvenser av) metodekall, og sekvensdiagrammer viser metodekall mellom objekter langs en tidslinje.</p>

<p><strong>K</strong><strong>lassediagrammer (klasser og assosiasjoner inkl. kardinalitet)</strong></p>

<p>viser klassestrukturen til et program, med innholdet i klasser (attributter og operasjoner) og hvordan de er koblet sammen med arv og assosiasjoner.</p>

:ET