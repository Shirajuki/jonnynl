I"–'<h1 id="innkapsling-og-validering---teorisp√∏rsm√•l">Innkapsling og validering - Teorisp√∏rsm√•l</h1>
<ol>
  <li>a) Hva er forskjellen p√•<strong>public</strong>, <strong>protected</strong> og <strong>private</strong>?
<span style="color:#ff7e7e;"><strong>public</strong></span><span style="color:#ff7e7e;"> brukes n√•r andre klasser skal kunne instansiere klassen direkte med </span><span style="color:#ff7e7e;">**new <klasse>(‚Ä¶)**&lt;/span&gt;<span style="color:#ff7e7e;">. </span><span style="color:#ff7e7e;">**protected**</span><span style="color:#ff7e7e;">-konstrukt√∏rer brukes for √• initialisere felt i en superklasse og kalles av subklassens konstrukt√∏r med </span><span style="color:#ff7e7e;">**super(‚Ä¶)**</span><span style="color:#ff7e7e;">. </span><span style="color:#ff7e7e;">**private**</span><span style="color:#ff7e7e;"> brukes p√• hjelpekonstrukt√∏rer internt i en klasse og kalles med </span><span style="color:#ff7e7e;">**this(‚Ä¶)**</span><span style="color:#ff7e7e;">.</span>
b) Hva b√∏r i utgangspunktet alle variablene dine v√¶re deklarert som? 
<span style="color:#ff7e7e;">Innkapsling handler om √•: 
1) hindre at en kan sette objekter til en ulovlig tilstand og 
2) skjule representasjonsdetaljer slik at en kan gj√∏re endringer uten at andre klasser ogs√• m√• endres. </span></klasse></span></li>
  <li>Hvilke to metoder er vanlig √• ha for variabler i Java? 
<span style="color:#ff7e7e;">Generelt er det en fordel √• redusere settet med metoder, siden det gir frihet til √• endre klasse siden. N√•r felt initaliseres i en konstrukt√∏r, s√• trengs som oftest ikke set-metoder. Her trenger en heller ikke get-metoder, siden metodene som stiller sp√∏rsm√•l og sjekker svar utgj√∏r et komplett API for klassen.
</span>
<span style="color:#ff7e7e;">get-metoder gir tilgang til tilstanden uten √• ‚Äùavsl√∏re‚Äù hvilke felt som brukes for √• representere tilstanden.</span></li>
  <li>Hva er forskjellen p√• ugyldig tilstand og ugyldig argument? 
<span style="color:#ff7e7e;">Hva er form√•let med / begrunnelsen for √• implementere en eller flere konstrukt√∏rer for en klasse : En konstrukt√∏r har som form√•l √• </span><span style="color:#ff7e7e;"><em>initialisere</em> </span><span style="color:#ff7e7e;">et objekt, slik at det fra starten av har en </span><span style="color:#ff7e7e;"><em>gyldig</em> </span><span style="color:#ff7e7e;">tilstand.</span></li>
  <li>Hva er meningen med innkapsling og validering? 
<span style="color:#ff7e7e;">Innkapsling skal sikre et objekt starter og forblir i en </span><span style="color:#ff7e7e;"><em>gyldig tilstand</em></span><span style="color:#ff7e7e;"> og at innholdet kan leses og endres uten √• avdekke den </span><span style="color:#ff7e7e;"><em>interne representasjonen og implementasjonen</em></span><span style="color:#ff7e7e;">. Mekanismen er bruk av synlighetsmodifikatorer, som reduserer muligheten (andre) klasser har til √• referere til felt og metoder.</span></li>
</ol>

<p><span style="color:#ff7e7e;">En kan kategorisere innkapslingsmetoder som enten lese- eller endringsmetoder. Den viktigste oppgaven til endringsmetodene, bortsett fra √• utf√∏re selve endringen er √• sjekke (validere) om den nye verdien (eller nye verdiene) er lovlige/gyldige, f√∏r de evt. endres, f.eks. at et navn kun inneholder bokstaver og mellomrom.</span></p>
<ol>
  <li>Trenger man √• validere argumenter som tas inn i konstrukt√∏ren? 
<span style="color:#ff7e7e;"><strong>public final int hours, minutes;
final</strong></span><span style="color:#ff7e7e;"> betyr her at feltet ikke kan endres </span><span style="color:#ff7e7e;"><em>etter</em></span><span style="color:#ff7e7e;"> at det er satt i konstrukt√∏ren. </span><span style="color:#ff7e7e;">Selv om feltene er </span><span style="color:#ff7e7e;"><strong>public</strong></span><span style="color:#ff7e7e;"> s√• sikres innkapsling ved at felt-verdiene forblir korrekte, siden kode utenfor klassen ikke kan sette feltene til ugyldige verdier Imidlertid er det ikke i tr√•d med innkapsling at kode gj√∏res avhengig av at data er lagret i spesifikke felt. Ved bruk av get-metoder f√•r implementasjonsklassen st√∏rre frihet til √• endre interne detaljer, uten at annen kode blir p√•virket.</span>
<span style="color:#ff7e7e;"><strong>final</strong></span><span style="color:#ff7e7e;"> betyr her at feltet ikke skal kunne endres etter at det er initialisert. Da m√• en enten initialisere i deklarasjonen eller i en eller flere konstrukt√∏rer, eller en kombinasjon.
</span>
<span style="color:#ff7e7e;">Klasser utformet slik at instanser ikke skal kunne endres etter at de er opprettet, </span><span style="color:#ff7e7e;"><em>generelle</em></span><span style="color:#ff7e7e;"> fordeler og ulemper med klasser som gir ikke-modifiserbare (immutable) instanser er at klassen blir enklere, og minsker bl.a. behovet for validering. Instanser kan brukes av flere deler av et program, uten risiko for at en del endrer p√• dem og √∏delegger for en annen del. Ulempen er at en m√• lage nye instanser hvis de m√• rettes p√•, istedenfor √• endre dem direkte.</span>
<span style="color:#ff7e7e;">Den generelle teknikken og navnekonvensjonen(e) for √• representere og kapsle inn en enkel verdi, f.eks. tall eller objektreferanse, som skal kunne endres etter at objektet er opprettet:</span>
<span style="color:#ff7e7e;">**private T value;
public T getValue() { ‚Ä¶ }
**</span><span style="color:#ff7e7e;">(Dersom X er boolean/Boolean, s√• brukes gjerne ‚Äùis‚Äù som prefiks istedenfor ‚Äùget‚Äù).</span>
<span style="color:#ff7e7e;"><strong>public void setValue(T value) { ‚Ä¶ }</strong></span>
<span style="color:#ff7e7e;">Med static-modifikatoren vil metodene ikke kunne referere til et bestemt RadioAlphabet-objekt. En kan for s√• vidt gj√∏re alfabetet static ogs√•, men da vil en bare kunne ha ett globalt alfabet.
En metode kan v√¶re </span><span style="color:#ff7e7e;"><strong>static</strong></span><span style="color:#ff7e7e;"> siden den ikke bruker felt eller metoder som er ikke-</span><span style="color:#ff7e7e;"><strong>static</strong></span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;">I forhold til innkapsling, hovedgrunnen til √• la en konstrukt√∏r ta en eller flere parametre : Parametrene til en konstrukt√∏r er informasjon som trengs for √• gi objektet en gyldig starttilstand, som oftest verdien til felt som m√• v√¶re satt og det ikke finnes noen fornuftig default-verdi.</span>
<span style="color:#ff7e7e;">Java ved gitte forutsetninger vil automatisk opprette en konstrukt√∏r for en klasse, slik at instanser av klassen kan opprettes, selv om en ikke eksplisitt har definert en konstrukt√∏r for klassen. Betingelsen(e) for at Java skal gj√∏re dette : Forutsetningen for √• automatisk opprette en konstrukt√∏r er at den er instansierbare dvs. ikke abstrakt, og det ikke er definert noen andre konstrukt√∏rer. En slik konstrukt√∏r vil v√¶re </span><span style="color:#ff7e7e;"><strong>public</strong></span><span style="color:#ff7e7e;"> og ha tom parameterliste.</span>
<span style="color:#ff7e7e;">En annen teknikk for initialisering enn deklarasjon er √• bruke en eller flere konstrukt√∏rer. Dette er metoder med samme navn som klassen som blir implisitt kalt ved bruk av new (med eller uten argumenter). </span><span style="color:#ff7e7e;">Fordeler</span><span style="color:#ff7e7e;">:
</span>    <ul>
      <li>en kan skrive mer komplisert kode for initialisering, med f.eks. valg og validering</li>
      <li>en kan (tvinges til √•) oppgi argumenter som kan brukes i initialiseringen</li>
      <li>konstrukt√∏rer hjelper en √• sikre tilstand ved bruk av innkapsling&lt;/span&gt;
<span style="color:#ff7e7e;">Ulemper</span><span style="color:#ff7e7e;">:</span></li>
      <li>koden for initialisering blir ofte langt unna feltene den initialiserer</li>
      <li>det er lett √• glemme √• initialisere felt&lt;/span&gt;
<span style="color:#ff7e7e;">Dette handler om</span><a href="https://www.ntnu.no/wiki/display/tdt4100/Innkapsling">innkapsling</a><span style="color:#ff7e7e;">, som har to aspekter: 1) sikring av gyldig tilstand og 2) skjuling av implementasjonsdetaljer, s√• koden lettere kan endres uten at andre klasser p√•virkes. Av disse to er aspekt 1) viktigst.</span>
<span style="color:#ff7e7e;">Den f√∏rste teknikken krever mindre kode og er derfor enklere √• lese og skrive. Siden en bruker </span><span style="color:#ff7e7e;"><strong>final</strong></span><span style="color:#ff7e7e;">-modifikatoren s√• sikres aspekt 1), siden verdiene/tilstanden ikke kan endres tross at feltet er </span><span style="color:#ff7e7e;"><strong>public</strong></span><span style="color:#ff7e7e;">. Imidlertid s√• er det andre aspektet ved innkapsling ikke ivaretatt, siden feltet er eksponert. Derfor er den andre teknikken √• foretrekke, som ivaretar begge aspektene.</span>
<span style="color:#ff7e7e;">Objekter som ikke kan endres, kan deles/brukes i flere datastrukturer uten fare for kluss. Hvis delte objekter kan endres, s√• m√• en v√¶re mer n√∏ye p√• hva en gj√∏r.</span>
<span style="color:#ff7e7e;">finne passende datastruktur og innkapslingsmetoder. En trenger bare √©n add-metode, selv om det er vist to har. For √• g√• gjennom segmentene trenger en b√•de √©n metode for </span><span style="color:#ff7e7e;"><strong>count/size</strong></span><span style="color:#ff7e7e;"> (ellers vet en ikke n√•r iterasjonen skal stoppe) og √©n for √• hente ut et element.
Det var veldig mange som lurte p√• formuleringen ‚Äùg√• gjennom dem basert p√• indeks‚Äù, antageligvis fordi det ikke var sagt at dette var </span><span style="color:#ff7e7e;"><em>innkapsling for andre klasser</em></span><span style="color:#ff7e7e;">, ikke til bruk internt i klassen.</span>
        <h1 id="grensesnittinterface---teorisp√∏rsm√•l">Grensesnitt/Interface - Teorisp√∏rsm√•l</h1>
      </li>
    </ul>
  </li>
  <li>Hvilket n√∏kkelord i Java brukes for √• angi at en klasse implementerer et grensesnitt?</li>
  <li>Hva er forskjellen p√• en klasse og et grensesnitt?</li>
  <li>Nevn tre bruksomr√•der hvor det er en fordel √• bruke grensesnitt.</li>
  <li>Kan grensesnitt definere private metoder?
    <ol>
      <li>Hvorfor gir/gir ikke dette mening?</li>
    </ol>
  </li>
  <li>Kan et grensesnitt implementere et annet grensesnitt?</li>
  <li>Kan et grensesnitt arve et annet grensesnitt?</li>
  <li>Hva er forskjellen p√• √• implementere et grensesnitt og √• arve fra en annen klasse?</li>
  <li>Hva er forskjellen p√• en abstrakt klasse og et grensesnitt?
    <ol>
      <li>Hvilke muligheter har man i en abstrakt klasse som man ikke har i et grensesnitt?</li>
    </ol>
  </li>
  <li>Definer (skriv ned) et grensesnitt etter hukommelsen.</li>
  <li>Kan et grensesnitt inneholde variabler?
    <ol>
      <li>Hva m√• eventuelt en variabel deklareres som for √• v√¶re tillatt i et grensesnitt?</li>
    </ol>
  </li>
  <li>Kan et grensesnitt definere konstrukt√∏rer?
<span style="color:#ff7e7e;">Et grensesnitt skal ikke ha konstrukt√∏rer og statiske metoder. Det er faktisk lov √• ha statiske metoder i grensesnitt i Java, men det h√∏rer ikke med i objektorientert tenkning.</span>
<span style="color:#ff7e7e;">Dice-grensesnittet </span><span style="color:#ff7e7e;"><em>m√•</em> </span><span style="color:#ff7e7e;">utvide (extends) Iterable<Integer> &lt;/span&gt;<span style="color:#ff7e7e;">_og kan_ </span><span style="color:#ff7e7e;">liste opp metoden(e) fra Iterable. for et grensesnitt kan gjenta metoder fra et grensesnitt det utvider, men m√• ikke. </span>
</Integer></span>    <h1 id="arv---teorisp√∏rsm√•l">Arv - Teorisp√∏rsm√•l</h1>
  </li>
  <li>Hva er forskjellen p√• en abstrakt klasse og et grensesnitt?
<span style="color:#ff7e7e;">En abstrakt klasse er en klasse som ikke kan instansieres, enten fordi den er ufullstendig ved at den deklarerer √©n eller flere abstrakte (tomme) metoder, eller fordi det ikke gir mening. Ingen av de tre klassene b√∏r v√¶re abstrakte, siden alle er fullstendige og implementerer en nyttig relasjon.</span></li>
  <li>Hvilke krav m√• en subklasse oppfylle for at det skal v√¶re naturlig for den √• arve fra en superklasse?</li>
  <li>Hvilket n√∏kkelord brukes for √• arve fra en annen klasse i Java?</li>
  <li>Hvor mange klasser kan en subklasse arve fra?</li>
  <li>Du har tre klasser: Human, Person og Student. Student arver fra Person, og Person arver fra Human. Du lager et objekt av hver klasse: human, person, student.
    <ol>
      <li>Har student tilgang til feltene og metodene i Human?</li>
      <li>Hva vil ‚Äúhuman instanceof Student‚Äù returnere?</li>
      <li>Hva vil ‚Äústudent instanceof Human‚Äù returnere?</li>
    </ol>
  </li>
  <li>N√•r en subklasse arver fra en superklasse, f√•r den tilgang til konstrukt√∏rene til superklassen?
    <ol>
      <li>N√•r f√•r den eventuelt (ikke) det?</li>
    </ol>
  </li>
  <li>Forklar hvordan bruk av protected-felt/metoder fungerer ved arv.</li>
  <li>Kan man instansiere en abstrakt klasse?
<span style="color:#ff7e7e;">2 klasser har en del felles egenskaper, som kan samles i en felles superklasse kalt </span><span style="color:#ff7e7e;"><strong>MenuItem</strong></span><span style="color:#ff7e7e;">:</span><span style="color:#ff7e7e;">
Her er poenget √• samle det som er felles. Klassen b√∏r v√¶re abstract, siden det ikke gir mening √• instansere den.</span></li>
  <li>Er det n√∏dvendig √• bruke annotasjonen @Override n√•r man redefinerer en arvet metode?</li>
  <li>Du har arvet en metode fra en superklasse og redefinert den i din egen klasse. Hvordan kan man bruke metoden som var definert i superklassen?</li>
  <li>Du skriver din egen konstrukt√∏r i en subklasse, men √∏nsker √• kalle superklassens konstrukt√∏r for √• slippe √• kopiere kode. Hvordan gj√∏r du dette?
<span style="color:#ff7e7e;">- N√•r en arver s√• kan en ikke kun arve de metodene en √∏nsker, men f√•r alle med p√• kj√∏pet. Da vil en v√¶re n√∏dt til √• redefinere alle en ikke trenger/√∏nsker at skal v√¶re tilgjengelig.
</span>    <ul>
      <li>&lt;/span&gt;<span style="color:#ff7e7e;">Det vil ikke alltid v√¶re logisk riktig at klassen skal v√¶re </span><span style="color:#ff7e7e;">**instanceof List<X>**&lt;/span&gt;<span style="color:#ff7e7e;"></span></X></span></li>
      <li>&lt;/span&gt;<span style="color:#ff7e7e;">(Teknikken kan bare brukes for √©n slik liste, siden en bare kan arve fra √©n implementasjonsklasse).</span>
<span style="color:#ff7e7e;"><strong>super()</strong></span><span style="color:#ff7e7e;"> kaller konstrukt√∏ren i superklassen og trengs for √• sikre at ogs√• superklassens konstrukt√∏r blir kj√∏rt. Her er super-klassen implisitt Object-klassen. Hvis linja ikke er med, s√• vil et tilsvarende kall, alts√• til en konstrukt√∏r uten argumenter, bli lagt til av kompilatoren. Derfor kan vi trygt fjerne linja.</span>
<span style="color:#ff7e7e;">Poenget her at siden </span><span style="color:#ff7e7e;"><strong>Course</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>Meal</strong></span><span style="color:#ff7e7e;"> n√• har en felles superklasse, s√• blir det enklere √• ha datastrukturer med begge disse objekttypene i. Dette forenkler b√•de </span><span style="color:#ff7e7e;"><strong>Menu</strong></span><span style="color:#ff7e7e;">- og </span><span style="color:#ff7e7e;"><strong>Table</strong></span><span style="color:#ff7e7e;">-klassene. En blir her bedt om √• skrive mye kode p√• nytt, og siden eksamen var digital, s√• b√∏r det v√¶re greit i praksis. Det er greit √• bare skrive de delene som blir endret, til n√∏d forklare endringene med tekst.</span>
<span style="color:#ff7e7e;">Det disse tre implementasjonene har felles er </span><span style="color:#ff7e7e;"><strong>score</strong></span><span style="color:#ff7e7e;">-verdien, s√• denne kan legges i den abstrakte </span><span style="color:#ff7e7e;"><strong>AbstractScorer</strong></span><span style="color:#ff7e7e;">-klassen, initialiseres ved √• kalle </span><span style="color:#ff7e7e;"><strong>super(score)</strong></span><span style="color:#ff7e7e;"> √∏verst i subklasse-konstrukt√∏rene og leses med </span><span style="color:#ff7e7e;"><strong>getScore()</strong></span><span style="color:#ff7e7e;">:</span>
<span style="color:#ff7e7e;">En antar at det finnes ulike klasser for ulike typer fremkomstmidler en kan leie. Hver type skal kunne ha sine egne sett med verdier brukt til prising, f.eks. pris pr. time og pris pr. Tidsforlengelse. Hvordan arvingsmekanismen kan benyttes?</span></li>
      <li>Det naturlige er da √• lage en abstrakt klasse &lt;/span&gt;<span style="color:#ff7e7e;"><strong>Vehicle</strong></span><span style="color:#ff7e7e;"> som inneholder priselementer (pris per time, forsentbot etc) og gettere/settere (som </span><span style="color:#ff7e7e;"><strong>getHourRate</strong></span><span style="color:#ff7e7e;">, </span><span style="color:#ff7e7e;"><strong>setLocation</strong></span><span style="color:#ff7e7e;"> m.m). Ikke alle av disse trenger √• v√¶re abstrakte, eksempelvis kan det som har med lokasjon √• gj√∏re v√¶re implementert i Vehicle. Alle fremkomstmidler (</span><span style="color:#ff7e7e;"><strong>Bike</strong></span><span style="color:#ff7e7e;">, </span><span style="color:#ff7e7e;"><strong>Hoverboard</strong></span><span style="color:#ff7e7e;"> og slikt) og m√• s√• arve denne klassen og kan redefinere metoder for √• endre verdiene/logikken som brukes i prisberegningen. Der en i </span><span style="color:#ff7e7e;"><strong>BikeRental</strong></span><span style="color:#ff7e7e;"> (som egentlig burde skifte navn til </span><span style="color:#ff7e7e;"><strong>VehicleRental</strong></span><span style="color:#ff7e7e;">) refererer til </span><span style="color:#ff7e7e;"><strong>Bike</strong></span><span style="color:#ff7e7e;"> m√• en n√• i stedet referere til den abstrakte klassen </span><span style="color:#ff7e7e;"><strong>Vehicle</strong></span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;">Vi lager en abstrakt klasse basert p√• Trip og gj√∏r estimateTime abstract:
S√• lar vi Trip arve fra denne og implementere estimateTime som over.
Andre varianter (interface) vil gj√∏re det samme, men implementere estimateTime med annen logikk. Det er strengt tatt ikke n√∏dvendig √• ha en abstrakt klasse, en kan alternativt bare arve fra Trip.</span>
<span style="color:#ff7e7e;"><strong>SimpleTable</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>CompositeTable</strong></span><span style="color:#ff7e7e;"> blir subklasser av Table, som selv enten blir et grensesnitt eller en abstrakt klasse med i hvertfall </span><span style="color:#ff7e7e;"><strong>getCapacity</strong></span><span style="color:#ff7e7e;">-metoden. De to variantene er vist under. </span><span style="color:#ff7e7e;"><strong>SimpleTable</strong></span><span style="color:#ff7e7e;"> kan ta over det meste av </span><span style="color:#ff7e7e;"><strong>Table</strong></span><span style="color:#ff7e7e;">-koden, evt. arve alt. </span><span style="color:#ff7e7e;"><strong>CompositeTable</strong></span><span style="color:#ff7e7e;"> kapsler inn informasjonen fra </span><span style="color:#ff7e7e;"><strong>mergeTable</strong></span><span style="color:#ff7e7e;"> og bruker de to </span><span style="color:#ff7e7e;"><strong>Table</strong></span><span style="color:#ff7e7e;">-objektene til √• beregne kapasiteten. Alternativt kan </span><span style="color:#ff7e7e;"><strong>Table</strong></span><span style="color:#ff7e7e;"> beholde </span><span style="color:#ff7e7e;"><strong>capacity</strong></span><span style="color:#ff7e7e;">-feltet og </span><span style="color:#ff7e7e;"><strong>getCapacity()</strong></span><span style="color:#ff7e7e;">-metoden og de to andre initialiserer </span><span style="color:#ff7e7e;"><strong>capacity</strong></span><span style="color:#ff7e7e;"> med </span><span style="color:#ff7e7e;"><strong>super(‚Ä¶)</strong></span><span style="color:#ff7e7e;">. Vi har her ikke lagt opp til at </span><span style="color:#ff7e7e;"><strong>CompositeTable</strong></span><span style="color:#ff7e7e;">-objekter skal f√• et l√∏penummer, men det er greit √• la den funksjonaliteten v√¶re en del av en abstract </span><span style="color:#ff7e7e;"><strong>Table</strong></span><span style="color:#ff7e7e;">-(super)klasse.</span>
<span style="color:#ff7e7e;">Her er poenget √• skille ut det som har med </span><span style="color:#ff7e7e;"><strong>score</strong></span><span style="color:#ff7e7e;"> √• gj√∏re i en abstrakt superklasse, nemlig feltet </span><span style="color:#ff7e7e;"><strong>score</strong></span><span style="color:#ff7e7e;">, (den delen av) konstrukt√∏ren som tar inn og setter </span><span style="color:#ff7e7e;"><strong>score</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>getScore</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>setScore</strong></span><span style="color:#ff7e7e;">. Dette er viktigst.</span></li>
      <li>Hvis en lar den abstrakte superklassen implementere Dice-grensesnittet evt. deklarer en del av Dice sine metoder som abstrakte metoder, s√• kan enda flere metoder implementeres, f.eks. trenger toString og getValueCount bare getDieCount og getDieValue. En trenger ikke implementere disse, men forklare at det g√•r an og vil v√¶re lurt.&lt;/span&gt;</li>
    </ul>
  </li>
</ol>

<h1 id="delegering---teorisp√∏rsm√•l">Delegering - Teorisp√∏rsm√•l</h1>
<ol>
  <li>Forklar forholdet mellom en delegat og en delegerende.
<a href="https://www.ntnu.no/wiki/display/tdt4100/Delegeringsteknikken">Delegeringsteknikken</a><span style="color:#ff7e7e;"> i praksis, hvor en instans av (en implementasjon av) et grensesnitt bruker en eller flere andre instanser av (implementasjoner av) samme grensesnitt, til √• gj√∏re jobben.</span></li>
  <li>I et firma med en Manager og flere Coworkers, hvem er naturlig de(n) delegerende og hvem er delegat(er)?</li>
  <li>Forklar hvordan det kan v√¶re nyttig √• benytte grensesnitt i forbindelse med delegering.
    <ol>
      <li>Ved √• benytte grensesnitt for en delegat-klasse, hvilke fordeler f√•r man?</li>
    </ol>
  </li>
  <li>N√•r kan det v√¶re smart √• benytte delegeringsteknikken fremfor arv?
<span style="color:#ff7e7e;">Delegering er en teknikk hvor et objekt, videreformidler kall til en ‚Äùdelegat‚Äù n√•r det er behov for delegatens ferdigheter. I dette tilfellet er det viktig at TimeSlot-objektene som ligger i delegaten regnes med i logikken. F.eks. m√• </span><span style="color:#ff7e7e;"><strong>getTimeSlotAt(‚Ä¶)</strong></span><span style="color:#ff7e7e;">-metoden sjekke egne TimeSlot-objekter og delegatens og returnere det tidligste av de to.</span>
<span style="color:#ff7e7e;">I del 2 ble utregning av kostnad ‚Äòhardkodet‚Äô inn i </span><span style="color:#ff7e7e;"><strong>rentBike</strong></span><span style="color:#ff7e7e;">. Hvis man skal st√∏tte utregning av kostnader ved hjelp av delegering, s√• m√• man lage et grensesnitt (interface) som inneholder en metode for beregning av pris. I LF har vi laget grensesnittet </span><span style="color:#ff7e7e;"><strong>PricePolicy</strong></span><span style="color:#ff7e7e;">, som blir implementert av klassen </span><span style="color:#ff7e7e;"><strong>DefaultPricePolicy</strong></span><span style="color:#ff7e7e;">. I del 2 ble all beregning gjort i en egen hjelpemetode, </span><span style="color:#ff7e7e;"><strong>computePrice</strong></span><span style="color:#ff7e7e;">. Det er derfor helt greit at grensesnittet inneholder nettopp denne metoden. I </span><span style="color:#ff7e7e;"><strong>BikeRental</strong></span><span style="color:#ff7e7e;"> m√• en s√• opprette et </span><span style="color:#ff7e7e;"><strong>DefaultPricePolicy</strong></span><span style="color:#ff7e7e;">-objekt, og kalle dennes </span><span style="color:#ff7e7e;"><strong>computePrice</strong></span><span style="color:#ff7e7e;"> for √• beregne pris. Hvis en vil bruke en annen prisingslogikk, s√• bruker man bare en annen implementasjon.</span></li>
</ol>

<p><span style="color:#ff7e7e;">en kan ogs√• bruke delegering for √• tilby </span><span style="color:#ff7e7e;"><em>individuell</em></span><span style="color:#ff7e7e;"> prising (alts√• pr. </span><span style="color:#ff7e7e;"><strong>Person</strong></span><span style="color:#ff7e7e;">), f.eks. Bonus-ordninger: I 3a ble det lagt opp til delegering av kostnadsberegning, men dette var ikke knyttet til enkeltpersoner. For √• implementere individuell prising kan en heller lage et sett med ulike </span><span style="color:#ff7e7e;"><strong>PricePolicy</strong></span><span style="color:#ff7e7e;">, (studenter, barn, voksne etc.) og knyttet disse til </span><span style="color:#ff7e7e;"><strong>Person</strong></span><span style="color:#ff7e7e;">-objektet (med gettere og settere). N√•r </span><span style="color:#ff7e7e;"><strong>rentBike</strong></span><span style="color:#ff7e7e;"> skal beregne kostnad m√• en s√• delegere til </span><span style="color:#ff7e7e;"><strong>Person</strong></span><span style="color:#ff7e7e;">-objektet (som igjen ligger i </span><span style="color:#ff7e7e;"><strong>Bike</strong></span><span style="color:#ff7e7e;">) sin </span><span style="color:#ff7e7e;"><strong>PricePolicy</strong></span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;">Delegeringsteknikken er mer fleksibel enn arv, fordi en n√•r som helst kan bytte ut TimeEstimator-objektet og dermed ogs√• endre oppf√∏rselen til estimateTime-metoden. Arv-mekanismen frigj√∏res dessuten til andre mer ‚Äùverdige‚Äù form√•l.</span>
<span style="color:#ff7e7e;">Poenget her er √• gj√∏re som beskrevet i oppgaven, √• bruke </span><span style="color:#ff7e7e;"><strong>rel2</strong></span><span style="color:#ff7e7e;"> p√• resultatet av √• bruke </span><span style="color:#ff7e7e;"><strong>rel1</strong></span><span style="color:#ff7e7e;">. Her sjekkes det ikke for duplikater (som det sjelden er behov for med relasjoner av denne typen). Dette er </span><span style="color:#ff7e7e;"><em>delegeringsteknikken</em></span><span style="color:#ff7e7e;"> i praksis, som kjennetegnes ved at et </span><span style="color:#ff7e7e;"><em>delegerende</em></span><span style="color:#ff7e7e;"> objekt, som skal utf√∏re en oppgave, ber en eller flere </span><span style="color:#ff7e7e;"><em>delegater</em></span><span style="color:#ff7e7e;"> om √• utf√∏re (omtrent) samme oppgave, for s√• √• kombinere resultatene. Her delegeres det til </span><span style="color:#ff7e7e;"><strong>rel1</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>rel2</strong></span><span style="color:#ff7e7e;">, som implementerer samme grensesnitt som </span><span style="color:#ff7e7e;"><strong>Relation2</strong></span><span style="color:#ff7e7e;">.</span></p>
<h1 id="observat√∏r-observert-teknikken---teorisp√∏rsm√•l">Observat√∏r-observert-teknikken - Teorisp√∏rsm√•l</h1>
<ol>
  <li>P√• hvilken m√•te kan observat√∏r-observert-teknikken hjelpe til √• holde tilstanden i et program konsistent?
<span style="color:#ff7e7e;">Observat√∏r-observert-teknikken brukes n√•r en eller flere objekter, her kalt observat√∏rer, m√• holdes konsistent med et annet objekt, her kalt observert, og det observerte objektet sin implementasjon ikke skal v√¶re for tett knyttet til observat√∏renes. Teknikken er basert p√• at det observerte objektet sier fra til en eller flere observat√∏rer om at tilstanden er endret, slik at observat√∏rene kan oppdatere sin tilstand ift. deres regler for konsistens.</span></li>
  <li>Nevn (minst) tre metoder som burde v√¶re med i de aller fleste implementasjoner av observat√∏r-observert-teknikken.</li>
  <li>Hvorfor kan det v√¶re lurt √• benytte grensesnitt for den observerte parten i et observat√∏r-observert-forhold?</li>
  <li>Hvorfor kan det v√¶re lurt √• benytte grensesnitt for observat√∏r-parten i et observat√∏r-observert-forhold?</li>
  <li>Tenk at en nettside oppdateres jevnlig, og du √∏nsker √• f√• et varsel til mobilen din hver gang nettsiden oppdateres. Hvilken av partene er den observerte og og hvilken er observat√∏r?</li>
  <li>Hvorfor l√∏nner det seg √• bruke observat√∏r-observert-teknikken fremfor √• jevnlig sjekke om et objekt har endret tilstand?
<span style="color:#ff7e7e;">Dette er standard bruk av observat√∏r-observert-teknikken, alts√• m√• en ha felt med liste av lyttere, metoder for √• legge til og fjerne lyttere og helst en hjelpemetode for √• varsle dem.</span>
<span style="color:#ff7e7e;">Observat√∏r-observert-teknikken, lytte til endringer. Lytting med 1) et grensesnitt, 2) liste av lyttere, 3) add/remove-metoder for lyttere, 4) metode til lytterne og 5) kall av metode n√•r endring skjer.</span>
<span style="color:#ff7e7e;">Observerbarhet krever:
</span>    <ol>
      <li>at en holder styr p√• lytterne og</li>
      <li>at alle endringsmetoder kaller lytternes lyttermetode.&lt;/span&gt;
<span style="color:#ff7e7e;">Observert-observat√∏r-teknikken brukes til √• f√∏lge med p√• hvordan tilstanden til objekter endres over tid, typisk for √• sikre konsistens med andre objekter, f.eks. et GUI med ‚Äúindre‚Äù objekter. Et objekt er observerbart dersom en kan lese ut alle relevant tilstand og en kan f√• beskjed (lytte p√• hendelser) om n√•r og hvordan denne tilstanden endres.
 Det siste sp√∏rsm√•let er et luresp√∏rsm√•l: Dice er allerede observerbar! Siden tilstanden ikke kan endres, s√• trenger en ikke √• st√∏tte lyttere. Hvis tilstanden kunne endres, s√• m√•tte man 1) definert et lyttergrensesnitt, 2) hatt metoder for √• administrere (registrere og avregistrere) lyttere, 3) hatt metode(r) for √• sende ut varsler om tilstandsendringer og 4) kalt disse metodene i alle metoder som faktisk endrer tilstanden.</span>
<span style="color:#ff7e7e;">Den generelle teknikken er </span><span style="color:#ff7e7e;"><em>observat√∏r-observert</em></span><span style="color:#ff7e7e;">, som b√•de brukes for √• si fra om at tiden g√•r og om at </span><span style="color:#ff7e7e;"><strong>Trip</strong></span><span style="color:#ff7e7e;"> er endret. Tiden h√•ndteres ved √• anta at det finnes en </span><span style="color:#ff7e7e;"><strong>Clock</strong></span><span style="color:#ff7e7e;">-klasse, som kan si fra hvert minutt til et sett med lyttere. En kan f.eks. ha grensesnittet </span><span style="color:#ff7e7e;"><strong>ClockListener</strong></span><span style="color:#ff7e7e;"> med </span><span style="color:#ff7e7e;"><strong>minuttPassed()</strong></span><span style="color:#ff7e7e;">-metoden og metodene </span><span style="color:#ff7e7e;"><strong>addClockListener</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>removeClockListener</strong></span><span style="color:#ff7e7e;">. </span><span style="color:#ff7e7e;"><strong>Trip</strong></span><span style="color:#ff7e7e;"> m√• gj√∏res </span><span style="color:#ff7e7e;"><em>observerbar</em></span><span style="color:#ff7e7e;">: 1) en m√• ha lese-metoder for alle relevante data og 2) en m√• kunne registrere lyttere (som implementerer et lyttergrensesnitt f.eks. kalt </span><span style="color:#ff7e7e;"><strong>TripChangedListener</strong></span><span style="color:#ff7e7e;">) som f√•r beskjed n√•r objektet endres (f.eks. vha. en metode kalt </span><span style="color:#ff7e7e;"><strong>tripChanged</strong></span><span style="color:#ff7e7e;">).</span>
<span style="color:#ff7e7e;">Hva inneb√¶rer observerbarhet? Hvordan en gj√∏r en (egenskap i en) klasse observerbar?
</span>        <ul>
          <li>Observerbarhet handler om √• la et eller flere objekter (observat√∏rene/lytterne) f√• beskjed om endringer i et annet objekt (den observerte). Observert-klassen m√• administrere et sett med lyttere (objekter som implementerer et lyttergrensesnitt), vha. felt for Collection av lyttere og add/remove-metoder. Alle steder hvor tilstanden (til egenskapen) endres, m√• det skytes inn kode som sier fra til lytterne (kall p√• fire-metode, som g√•r gjennom lytterne).</li>
          <li>Capacity-egenskapen beregnes p√• bakgrunn av &lt;/span&gt;<span style="color:#ff7e7e;"><strong>tables</strong></span><span style="color:#ff7e7e;">- og </span><span style="color:#ff7e7e;"><strong>seatings</strong></span><span style="color:#ff7e7e;">-listene, og derfor m√• lytterne varsles hver gang disse endres (av </span><span style="color:#ff7e7e;"><strong>addTable</strong></span><span style="color:#ff7e7e;">, </span><span style="color:#ff7e7e;"><strong>removeTable</strong></span><span style="color:#ff7e7e;">, </span><span style="color:#ff7e7e;"><strong>addSeating</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>removeSeating</strong></span><span style="color:#ff7e7e;">). Det skilles ikke mellom om kapasiteten √∏ker eller minker, selv om det er √∏kning som </span><span style="color:#ff7e7e;"><strong>GuestManager</strong></span><span style="color:#ff7e7e;"> er interessert i. Lyttere registreres med </span><span style="color:#ff7e7e;"><strong>add</strong></span><span style="color:#ff7e7e;">/</span><span style="color:#ff7e7e;"><strong>removeCapacityListener</strong></span><span style="color:#ff7e7e;">-metoder og en </span><span style="color:#ff7e7e;"><strong>fireCapacityChanged</strong></span><span style="color:#ff7e7e;">-metode, som varsler lytterne (CapacityListener-implementasjoner), kalles av endringsmetodene.</span>
<span style="color:#ff7e7e;">Standardteknikken krever et passende lyttergrensesnitt og en liste av lyttere som kalles p√• passende sted. En bruker gjerne en Collection for √• lagre lytterne og add/remove-metoder for √• administrere lytterne.</span></li>
          <li>LF definerer lyttergrensesnittet &lt;/span&gt;<span style="color:#ff7e7e;"><strong>TreatmentListener</strong></span><span style="color:#ff7e7e;">. Dette grensesnittet har √©n metode, som kalles idet doktor-pasient-koblingen etableres, alts√• p√• tidspunktet det passer √• gi beskjed til pasienten om hvilken doktor hen skal g√• til. Metoden b√∏r ta inn faktisk pasient, doktor og akuttmottak (</span><span style="color:#ff7e7e;"><strong>TreatmentUnit</strong></span><span style="color:#ff7e7e;">).</span></li>
          <li>Endringer som m√• gj√∏res i &lt;/span&gt;<span style="color:#ff7e7e;"><em>den</em></span><span style="color:#ff7e7e;"><em>observerte</em></span><span style="color:#ff7e7e;">, </span><span style="color:#ff7e7e;"><strong>TreatmentUnit</strong></span><span style="color:#ff7e7e;">, er at alle lytterne lagres i en </span><span style="color:#ff7e7e;"><strong>private</strong></span><span style="color:#ff7e7e;"><strong>Collection</strong></span><span style="color:#ff7e7e;"> av type </span><span style="color:#ff7e7e;"><strong>TreatmentListener</strong></span><span style="color:#ff7e7e;">, og at den legger inn relevante </span><span style="color:#ff7e7e;"><strong>public add/remove</strong></span><span style="color:#ff7e7e;"> til denne. I tillegg defineres hjelpemetoden </span><span style="color:#ff7e7e;"><strong>fireTreatmentStarted</strong></span><span style="color:#ff7e7e;">, som kalles rett etter at </span><span style="color:#ff7e7e;"><strong>setPatient</strong></span><span style="color:#ff7e7e;"> har etablert en ny doktor-pasient-kobling (i b√•de </span><span style="color:#ff7e7e;"><strong>startTreatment(Doctor)</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>startTreatment(Patient)</strong></span><span style="color:#ff7e7e;">).</span></li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<h1 id="typer---teorisp√∏rsm√•l">Typer - Teorisp√∏rsm√•l</h1>
<ol>
  <li>**Collection<String> strings = new ArrayList<String>()**
a) Hva er sammenhengen med typen deklarert p√• venstre-side og typen deklarert p√• h√∏yre-side?
<span style="color:#ff7e7e;">Hvordan p√•virker </span><span style="color:#ff7e7e;">**String**</span><span style="color:#ff7e7e;">-spesialiseringen (alts√• det som st√•r mellom </span><span style="color:#ff7e7e;">**&lt; &gt;**</span><span style="color:#ff7e7e;">) bruken av </span><span style="color:#ff7e7e;">**strings**</span><span style="color:#ff7e7e;">-variabelen?
</span></String></String>    <ul>
      <li>Typen p√• h√∏yresiden m√• v√¶re den samme eller en subklasse (inkl. implementasjonsklasse, som her) av typen p√• venstresiden. Spesialiseringen m√• v√¶re den samme. &lt;/span&gt;<span style="color:#ff7e7e;"><strong>String</strong></span><span style="color:#ff7e7e;">-spesialiseringen p√•virker parametertyper og returtyper for </span><span style="color:#ff7e7e;"><strong>Collection</strong></span><span style="color:#ff7e7e;">- og </span><span style="color:#ff7e7e;"><strong>ArrayList</strong></span><span style="color:#ff7e7e;">-metodene. F.eks. vil </span><span style="color:#ff7e7e;"><strong>get</strong></span><span style="color:#ff7e7e;"> returnere </span><span style="color:#ff7e7e;"><strong>String</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>add</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>set</strong></span><span style="color:#ff7e7e;">-metodene vil ta en </span><span style="color:#ff7e7e;"><strong>String</strong></span><span style="color:#ff7e7e;"> som parameter.</span>
b) Hvordan p√•virker det videre programmering at det st√•r <String>?</String></li>
    </ul>
  </li>
  <li>Hva er casting?</li>
  <li>a) Hva er forskjellen p√• int og Integer?
b) Gi et eksempel p√• n√•r en m√• bruke Integer.</li>
  <li>Hva er typen til f√∏lgende uttrykk? 
a) ‚ÄúJava‚Äù + ‚ÄúG√∏y‚Äù;  // String + String = String
b) 1/2;  // int / int = int
c) (‚ÄúJ‚Äù+‚Äùava‚Äù).charAt(2);  // char</li>
  <li>Public Eksamen(String besvarelser‚Ä¶){} 
Hvor mange String-objekter kan sendes inn i denne konstrukt√∏ren?<br />
<span style="color:#ff7e7e;">Man m√• </span><span style="color:#ff7e7e;">deklarere </span><span style="color:#ff7e7e;"><em>typen</em></span><span style="color:#ff7e7e;"> til alle felt, variabler og parametre (i motsetning f.eks. Python, Javascript og Matlab). De viktigste fordelene er at </span><span style="color:#ff7e7e;">det </span><span style="color:#ff7e7e;">blir lettere √•:</span></li>
  <li><span style="color:#ff7e7e;">oppdage/hindre feil bruk av verdier (for verkt√∏y, kompilator og programmerer)</span></li>
  <li><span style="color:#ff7e7e;">tilby hjelp til kodingen, f.eks. foresl√• metoder</span></li>
  <li><span style="color:#ff7e7e;">kompilere til effektiv kode</span></li>
</ol>

<p><span style="color:#ff7e7e;">At metoder i en klasse kan ha samme navn kalles ‚Äùoverloading‚Äù. For √• avgj√∏re hvilken som skal kalles, brukes de deklarerte typene til argumentene (ikke returverdien). Merk at dette er noe annet enn polymorfi, som handler om at subklasser kan ha ulike implementasjoner av metoder definert i en felles superklasse.
</span>
<span style="color:#ff7e7e;">Hensikten med √• definere en </span><span style="color:#ff7e7e;"><strong>toString()</strong></span><span style="color:#ff7e7e;">-metode er at </span><span style="color:#ff7e7e;"><strong>toString()</strong></span><span style="color:#ff7e7e;">-metoden brukes implisitt n√•r Java lager String-objekter av instanser ifm. bruk av </span><span style="color:#ff7e7e;"><strong>+</strong></span><span style="color:#ff7e7e;"> og IO og sikrer at tilstanden til instanser blir presentert p√• en nyttig m√•te.</span>
<span style="color:#ff7e7e;">
Hvordan er klassen kodet s√• det forklarende ordet/navnet vises ved utskrift, f.eks. med </span><span style="color:#ff7e7e;"><strong>System.out.println(‚Ä¶)</strong></span><span style="color:#ff7e7e;">? Ved utskrift s√• brukes implisitt </span><span style="color:#ff7e7e;"><strong>toString()</strong></span><span style="color:#ff7e7e;">-metoden, som er implementert og returnerer </span><span style="color:#ff7e7e;"><strong>label</strong></span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;">Et funksjonelt grensesnitt har bare √©n abstrakt metode, og resultatet av √• utf√∏re metoden skal alltid v√¶re det samme for samme argumenter. Dette gj√∏r at man kan tenke p√• implementasjonen som en matematisk funksjon. Det er ogs√• et poeng (men underordnet) at grensensittet er ment √• v√¶re den </span><span style="color:#ff7e7e;"><em>prim√¶re</em></span><span style="color:#ff7e7e;"> funksjonen til klassen som implementerer den. Ellers gir det ikke s√• mye mening √• bruke anonyme klasser/lambda-uttrykk til √• implementere grensesnittet. Et eksempel p√• dette er </span><span style="color:#ff7e7e;"><strong>Comparator</strong></span><span style="color:#ff7e7e;">, som kun implementeres for √• sammenligne argumentene. </span><span style="color:#ff7e7e;"><strong>Comparable</strong></span><span style="color:#ff7e7e;">-derimot, implementeres av dataklasser og er derfor en sekund√¶r funksjon, som det ikke er noe poeng √• implementere som prim√¶rfunksjon.</span>
<span style="color:#ff7e7e;"><strong>DiceScorer</strong></span><span style="color:#ff7e7e;">-grensesnittet er funksjonelt fordi det 1) har kun √©n abstrakt metode og 2) er ment √• v√¶re prim√¶rtfunksjonen til klassen som implementerer den.</span>
<span style="color:#ff7e7e;">Funksjonelle grensesnitt har bare √©n metode (krav 1), og den metoden er </span><span style="color:#ff7e7e;"><em>funksjonell</em></span><span style="color:#ff7e7e;"> fordi den for samme input(-parametre) alltid gir samme output(-verdi). En annen m√•te √• si det siste p√• er at den ikke har intern tilstand som p√•virker oppf√∏rselen og som kan endres. Det er ogs√• vanlig √• tenke p√• grensesnitt-metoden som klassens </span><span style="color:#ff7e7e;"><em>hovedfunksjon</em></span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;"><strong>CapacityListener</strong></span><span style="color:#ff7e7e;">-grensesnitt er (teknisk sett) funksjonelt, siden det bare har √©n (abstrakt) metode (og kan derfor implementeres med lambda-syntaksen). Dette kreves i et svar som f√•r poeng i det hele tatt. I tillegg b√∏r andre argumenter (for at grensesnittet ikke er funksjonelt) trekkes inn, f.eks. at metoden typisk ikke er implementasjonens prim√¶re funksjon og at en ikke tenker p√• den som en matematisk funksjon som kun er avhengig av argumentene.</span>
<span style="color:#ff7e7e;">Hjelpemetode </span><span style="color:#ff7e7e;"><strong>tokenize</strong></span><span style="color:#ff7e7e;">, som kan v√¶re nyttig ved innlesing og som kan antas ferdig implementert. Modifikatorer?
En slik hjelpemetode b√∏r for det f√∏rste v√¶re markert som </span><span style="color:#ff7e7e;"><strong>private</strong></span><span style="color:#ff7e7e;">, siden det ikke er naturlig at dette er en tjeneste som tilbys andre klasser. For det andre b√∏r den v√¶re markert som </span><span style="color:#ff7e7e;"><strong>static</strong></span><span style="color:#ff7e7e;">, siden den ikke bruker (leser eller endrer) tilstanden til noe </span><span style="color:#ff7e7e;"><strong>Family</strong></span><span style="color:#ff7e7e;">-objekt. Eneste grunn til at den ikke skal v√¶re </span><span style="color:#ff7e7e;"><strong>static</strong></span><span style="color:#ff7e7e;">, er hvis en subklasse av </span><span style="color:#ff7e7e;"><strong>Family</strong></span><span style="color:#ff7e7e;"> har behov for √• redefinere den, og det er ikke aktuelt her.</span>
<span style="color:#ff7e7e;">Her er poenget at en trenger en </span><span style="color:#ff7e7e;"><em>global</em></span><span style="color:#ff7e7e;"> teller, som en f√•r til i Java ved bruk av </span><span style="color:#ff7e7e;"><strong>static</strong></span><span style="color:#ff7e7e;">. Denne m√• brukes og √∏kes i </span><span style="color:#ff7e7e;"><strong>Table</strong></span><span style="color:#ff7e7e;"> sin konstrukt√∏r.</span></p>
<h1 id="testing---teorisp√∏rsm√•l">Testing - Teorisp√∏rsm√•l</h1>
<ol>
  <li>Hvilke tre ‚Äúfaser‚Äù g√•r man gjennom under kj√∏ring av en JUnit-test?
    <ol>
      <li>Hva m√• de ulike metodene i hver ‚Äúfase‚Äù hete?</li>
    </ol>
  </li>
  <li>Hvor mange test- metoder kan en JUnit-test inneholde?</li>
  <li>Hva er meningen med testing av programmer p√• enhetsniv√• (Slik JUnit gj√∏r)?
<span style="color:#ff7e7e;">Den </span><span style="color:#ff7e7e;"><em>generelle</em></span><span style="color:#ff7e7e;"> testeteknikken som JUnit-testing (og JExercise) baserer seg p√• er √• rigge opp objekter med en f√∏r-tilstand, endre tilstanden og sammenligne med forventet etter-tilstand. Noen ganger er det ingen f√∏r- og etter-tilstand, da en kun sjekker et selvstendig metodekall, dvs. sammenligner returverdi med fasiten.
</span>    <ul>
      <li>bruk av &lt;/span&gt;<span style="color:#ff7e7e;"><strong>assertTrue</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>==</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>ikke assertEquals</strong> </span><span style="color:#ff7e7e;">for √• sjekke for identisk likhet.</span></li>
    </ul>
  </li>
</ol>

<p><span style="color:#ff7e7e;">For √• teste iterasjon med foreach-l√∏kker, m√• vi bruke metoden som en slik l√∏kke (implisitt) bruker, nemlig </span><span style="color:#ff7e7e;"><strong>iterator()</strong></span><span style="color:#ff7e7e;">-metoden og </span><span style="color:#ff7e7e;"><strong>Iterator</strong></span><span style="color:#ff7e7e;">-objektet som denne returnerer. Her brukes objektene som er rigget opp i </span><span style="color:#ff7e7e;"><strong>setUp</strong></span><span style="color:#ff7e7e;">-metoden.</span></p>

<p><span style="color:#ff7e7e;">hvorfor det er mer komplisert √• teste </span><span style="color:#ff7e7e;"><strong>rentBike</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>returnBike</strong></span><span style="color:#ff7e7e;"> enn √• teste </span><span style="color:#ff7e7e;"><strong>getRentedBikes</strong></span><span style="color:#ff7e7e;">. Hvilke aspekter ved disse metodene er det som gj√∏r det mer komplisert?</span></p>
<ul>
  <li>&lt;/span&gt;<span style="color:#ff7e7e;"><strong>getRentedBikes</strong></span><span style="color:#ff7e7e;"> kan testes ved √• sjekke bare returverdier, etter √• ha rigget opp diverse objekter, siden metoden ikke har </span><span style="color:#ff7e7e;"><em>side-effekter</em></span><span style="color:#ff7e7e;">. Effekten av </span><span style="color:#ff7e7e;"><strong>rentBike</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>returnBike</strong></span><span style="color:#ff7e7e;"> er derimot endring av diverse datastrukturer, s√• disse m√• sjekkes etterp√•.</span></li>
</ul>

<h1 id="unntakexception">Unntak/Exception</h1>
<p><span style="color:#ff7e7e;">I metoder som endrer (en verdi i) et objekt, s√• b√∏r argumenter valideres. Dette m√• skje f√∏r selve endringen og i tilfelle ugyldig(e) verdier s√• kastes et unntak av typen </span><span style="color:#ff7e7e;"><strong>IllegalArgumentException(‚Ä¶)</strong></span><span style="color:#ff7e7e;">.</span></p>

<p><span style="color:#ff7e7e;">En s√•kalt </span><span style="color:#ff7e7e;"><em>checked exception</em></span><span style="color:#ff7e7e;"> er en subklasse av Exception som ikke samtidig er en subklasse av RuntimeException. En slik Exception m√• deklareres vha. </span><span style="color:#ff7e7e;"><strong>throws</strong></span><span style="color:#ff7e7e;"> og den kallende metoden m√• enten h√•ndtere unntaket med </span><span style="color:#ff7e7e;"><strong>try</strong></span><span style="color:#ff7e7e;">/</span><span style="color:#ff7e7e;"><strong>catch</strong></span><span style="color:#ff7e7e;"> eller deklarere det med </span><span style="color:#ff7e7e;"><strong>throw</strong></span><span style="color:#ff7e7e;">s.</span>
<span style="color:#ff7e7e;">Checked exception : en </span><span style="color:#ff7e7e;"><strong>Exception</strong></span><span style="color:#ff7e7e;"> som ikke er en </span><span style="color:#ff7e7e;"><strong>RuntimeException</strong></span><span style="color:#ff7e7e;"> er en </span><span style="color:#ff7e7e;"><em>checked</em></span><span style="color:#ff7e7e;"> exception. En slik unntakstype krever enten try/catch eller en </span><span style="color:#ff7e7e;"><strong>throws</strong></span><span style="color:#ff7e7e;">-deklarasjon for √• unng√• kompileringsfeil.</span></p>

<p><span style="color:#ff7e7e;">Metoder som sjekker argumentene sine f√∏r de utf√∏rer evt. endringer p√• objektet kalles </span><span style="color:#ff7e7e;"><em>validering</em></span><span style="color:#ff7e7e;"> (og er en viktig del av innkapsling). Det er lurt √• skille ut valideringen i en egen metode som kalles fra endringsmetodene. Metoden kan v√¶re </span><span style="color:#ff7e7e;"><strong>protected</strong></span><span style="color:#ff7e7e;">, s√• subklasser kan redefinere og gjenbruke valideringslogikken. Det er vanligst √• bruke en s√•kalt </span><span style="color:#ff7e7e;"><em>unchecked exception</em></span><span style="color:#ff7e7e;"> (usjekket unntak), som </span><span style="color:#ff7e7e;"><strong>IllegalArgumentException</strong></span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;"><strong>throws</strong></span><span style="color:#ff7e7e;">-deklarasjonen forteller leseren av koden at konstrukt√∏rene kan utl√∏se unntak. Siden unntakene er en subklasse av </span><span style="color:#ff7e7e;"><strong>RuntimeException</strong></span><span style="color:#ff7e7e;"> og dermed ikke </span><span style="color:#ff7e7e;"><em>checked</em></span><span style="color:#ff7e7e;">, s√• er det ikke n√∏dvendige.</span></p>

<h1 id="ulike-grensesnitt-typer">Ulike grensesnitt typer</h1>
<p>Standard funksjonelle grensesnitt, inkl. **Predicate<T>**, **Consumer<T>**, **Supplier<T>**, **Function&lt;T, R&gt;**, **BiFunction&lt;T1, T2, R&gt;**, **BinaryOperator<T>** og **UnaryOperator<T>**
<span style="color:#ff7e7e;">Grensesnitt som </span><span style="color:#ff7e7e;">**Predicate**</span><span style="color:#ff7e7e;"> er et s√•kalt </span><span style="color:#ff7e7e;">_funksjonelt_</span><span style="color:#ff7e7e;"> grensesnitt, siden det har √©n metode som (er ment som √•) oppf√∏rer seg som en matematisk funksjon.</span>
<span style="color:#ff7e7e;">Metoden deklareres som </span><span style="color:#ff7e7e;">**Collection<Person> getMatchingPersons(Collection<Person> persons, Predicate<Person> test)**&lt;/span&gt;<span style="color:#ff7e7e;">. Koden kan skrives p√• (minst) to m√•ter, enten som en √©n-linjer med </span><span style="color:#ff7e7e;">**Stream**</span><span style="color:#ff7e7e;">-teknikken eller med en l√∏kke som tester og legger til en resultat-liste. Kallet gj√∏res enklest med lambda-notasjonen:</span>
<span style="color:#ff7e7e;">**getMatchingPersons(persons, p -&gt; p.getGender() == ‚ÄôM‚Äô &amp;&amp; p.getAge() == 18)**</span>
Collection-rammeverket** (Collection<T>-, List<T>-, Set<T>, Map&lt;K, V&gt;-, Iterator<T>- og Iterable<T>-**grensesnittene og** ArrayList<T>- og HashMap&lt;K, V&gt;-klassene)**, inkludert bruk av **&lt;&gt;** i deklarasjoner, s√•kalte generics
<span style="color:#ff7e7e;">Hvis en klasse implementerer </span><span style="color:#ff7e7e;">**Iterable**</span><span style="color:#ff7e7e;"> s√• kan en bruke en instans av klassen p√• h√∏yresiden av :-tegnet i en for-each-l√∏kka, og iterere over alle verdier "inni" objektet. Her betyr det at vi kan skrive ... </span><span style="color:#ff7e7e;">**for (double v : values) { ... }**</span>
<span style="color:#ff7e7e;">Typen b√∏r v√¶re et grensesnitt fra </span><span style="color:#ff7e7e;">**Collection**</span><span style="color:#ff7e7e;">-rammeverket, enten </span><span style="color:#ff7e7e;">**Collection**</span><span style="color:#ff7e7e;"> eller </span><span style="color:#ff7e7e;">**List**</span><span style="color:#ff7e7e;">, som er spesialisert til element-typen </span><span style="color:#ff7e7e;">**Course**</span><span style="color:#ff7e7e;">. Her brukes </span><span style="color:#ff7e7e;">**Collection**</span><span style="color:#ff7e7e;">, fordi en ikke trenger andre metoder enn den deklarerer.</span>
<span style="color:#ff7e7e;">Her er poenget √• velge en type som passer til hvordan feltet brukes og verdien den blir tilordnet. Verdien som tilordnes er av typen </span><span style="color:#ff7e7e;">**List<Course>**&lt;/span&gt;<span style="color:#ff7e7e;">, s√• typen m√• enten v√¶re </span><span style="color:#ff7e7e;">**List**</span><span style="color:#ff7e7e;"> eller en av dens superklasser, som er </span><span style="color:#ff7e7e;">**Collection**</span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;">**Iterable**</span><span style="color:#ff7e7e;">. Hvis vi bare trenger metodene i </span><span style="color:#ff7e7e;">**Collection**</span><span style="color:#ff7e7e;">, som </span><span style="color:#ff7e7e;">**List**</span><span style="color:#ff7e7e;"> arver fra, s√• er det bedre √• bruke </span><span style="color:#ff7e7e;">**Collection**</span><span style="color:#ff7e7e;"> i deklarasjonen.</span>
<span style="color:#ff7e7e;">For √• kunne iterere med et </span><span style="color:#ff7e7e;">**Meal**</span><span style="color:#ff7e7e;">-objekt bak kolonet i en </span><span style="color:#ff7e7e;">**for**</span><span style="color:#ff7e7e;">-l√∏kke, s√• m√• </span><span style="color:#ff7e7e;">**Meal**</span><span style="color:#ff7e7e;">-klassen implementere </span><span style="color:#ff7e7e;">**Iterable<Course>**&lt;/span&gt;<span style="color:#ff7e7e;"> og derfor ha en </span><span style="color:#ff7e7e;">**iterator()**</span><span style="color:#ff7e7e;">-metode som returnerer </span><span style="color:#ff7e7e;">**Iterator<Course>**&lt;/span&gt;<span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;">Her er poenget √• skj√∏nne hvordan tabeller virker (opprettes, leses fra og skrives til) og logikken bak </span><span style="color:#ff7e7e;">**valueCounters**</span><span style="color:#ff7e7e;">-feltet, samt hvordan iterere med </span><span style="color:#ff7e7e;">**Iterator**</span><span style="color:#ff7e7e;"> (</span><span style="color:#ff7e7e;">**hasNext()**</span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;">**next()**</span><span style="color:#ff7e7e;">) og </span><span style="color:#ff7e7e;">**Iterable**</span><span style="color:#ff7e7e;"> (</span><span style="color:#ff7e7e;">**iterator()**</span><span style="color:#ff7e7e;">).</span>
<span style="color:#ff7e7e;">En kan lage en egen klasse som kombinerer mobilnummer og antall minutter i forkant de skal f√• varsel, eller bruke en </span><span style="color:#ff7e7e;">**Map&lt;String, Integer&gt;**</span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;">Hvis en klasse implementerer </span><span style="color:#ff7e7e;">**Iterable**</span><span style="color:#ff7e7e;">, s√• kan referanser til denne klassen brukes p√• h√∏yresiden av kolonet i en for-each-l√∏kke, f.eks. for (Person child : person). Se ogs√• </span><span style="color:#ff7e7e;">**getChildren**</span><span style="color:#ff7e7e;">-koden over.
Et (litt mindre relevant, og ikke p√•krevd) alternativ er </span><span style="color:#ff7e7e;">**Iterable.forEach(Consumer<Person>)**&lt;/span&gt;<span style="color:#ff7e7e;">. Dette er en s√•kalt </span><span style="color:#ff7e7e;">**default**</span><span style="color:#ff7e7e;">-metode (kom ikke frem i vedlegget) som en f√•r gratis n√•r en implementerer </span><span style="color:#ff7e7e;">**Iterable**</span><span style="color:#ff7e7e;">.</span>
<span style="color:#ff7e7e;">Forklar med tekst og kode sammenhengen mellom for-each-syntaksen, alts√• den p√• formen for (<type> <var> : <uttrykk>) ..., og &lt;/span&gt;<span style="color:#ff7e7e;">**Iterable**</span><span style="color:#ff7e7e;">- og </span><span style="color:#ff7e7e;">**Iterator**</span><span style="color:#ff7e7e;">-grensesnittene.</span></uttrykk></var></type></span></Person></span></Course></span></Course></span></Course></span></T></T></T></T></T></T></Person></Person></Person></span></T></T></T></T></T></p>
<ul>
  <li>Den vanlige m√•ten √• g√• gjennom en liste med elementer er med kode som den under til venstre. Dette kalles en &lt;/span&gt;<span style="color:#ff7e7e;"><strong>for-each</strong></span><span style="color:#ff7e7e;">-l√∏kke, fordi den g√•r gjennom hvert element i lista. Dette er egentlig spesial-syntaks for iterator-basert iterasjon, det er bare det at du aldri ser iteratoren. Funksjonelt sett er </span><span style="color:#ff7e7e;"><strong>for-each</strong></span><span style="color:#ff7e7e;">-l√∏kka til venstre ekvivalent med den </span><span style="color:#ff7e7e;"><strong>Iterator</strong></span><span style="color:#ff7e7e;">-baserte l√∏kka under til h√∏yre. Det er egentlig en smaksak hvilken en bruker, men den venstre varianten er √• foretrekke fordi den b√•de er enklere √• skrive og lese.</span></li>
  <li>Hvis en tenker over det, s√• er det nettopp &lt;/span&gt;<span style="color:#ff7e7e;"><strong>iterator()</strong></span><span style="color:#ff7e7e;">-metoden, som er n√∏kkelen til at </span><span style="color:#ff7e7e;"><strong>for-each</strong></span><span style="color:#ff7e7e;">-l√∏kka virker. Det holder at </span><span style="color:#ff7e7e;"><strong>stringListe</strong></span><span style="color:#ff7e7e;"> i kode-eksemplet har en slik metode, for at den skal kunne ‚Äúomskrives‚Äù til koden til h√∏yre som den tilsvarer. Denne koblingen mellom </span><span style="color:#ff7e7e;"><strong>for-each</strong></span><span style="color:#ff7e7e;">-l√∏kka og </span><span style="color:#ff7e7e;"><strong>iterator()</strong></span><span style="color:#ff7e7e;">-metoden er ikke tilfeldig, og for √• gj√∏re koblingen eksplisitt og mulig √• utnytte for klasser utenfor Collection-rammeverket, s√• er </span><span style="color:#ff7e7e;"><strong>iterator()</strong></span><span style="color:#ff7e7e;">-metoden definert i et eget grensesnitt ved navn </span><span style="color:#ff7e7e;"><strong>Iterable</strong></span><span style="color:#ff7e7e;"> (i </span><span style="color:#ff7e7e;"><strong>java.lang</strong></span><span style="color:#ff7e7e;">-pakken, s√• en slipper egen import-setning). Det er alts√• fordi en </span><span style="color:#ff7e7e;"><strong>ArrayList</strong></span><span style="color:#ff7e7e;"> implementerer </span><span style="color:#ff7e7e;"><strong>Iterable</strong></span><span style="color:#ff7e7e;"> at en </span><span style="color:#ff7e7e;"><strong>for-each</strong></span><span style="color:#ff7e7e;">-l√∏kke med en </span><span style="color:#ff7e7e;"><strong>ArrayList</strong></span><span style="color:#ff7e7e;"> virker! Og </span><span style="color:#ff7e7e;"><strong>ArrayList</strong></span><span style="color:#ff7e7e;"> implementerer </span><span style="color:#ff7e7e;"><strong>Iterable</strong></span><span style="color:#ff7e7e;"> fordi den implementerer </span><span style="color:#ff7e7e;"><strong>List</strong></span><span style="color:#ff7e7e;">, og </span><span style="color:#ff7e7e;"><strong>List</strong></span><span style="color:#ff7e7e;"> utvider </span><span style="color:#ff7e7e;"><strong>Collection</strong></span><span style="color:#ff7e7e;"> som utvider </span><span style="color:#ff7e7e;"><strong>Iterable</strong></span><span style="color:#ff7e7e;">. Denne koblingen mellom </span><span style="color:#ff7e7e;"><strong>ArrayList</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>Iterable</strong></span><span style="color:#ff7e7e;"> er illustrert under med et klassediagram:</span>
sortering med**Comparable<T>** og** Comparator<T>**
<span style="color:#ff7e7e;">Ved √• implementere </span><span style="color:#ff7e7e;">**Comparable**</span><span style="color:#ff7e7e;">-grensesnittet s√• kan </span><span style="color:#ff7e7e;">**Value**</span><span style="color:#ff7e7e;">-objekter sorteres vha. Java sine innebygde sort-metoder.</span>
<span style="color:#ff7e7e;">Dersom </span><span style="color:#ff7e7e;">**Course**</span><span style="color:#ff7e7e;">-klassen implementerer </span><span style="color:#ff7e7e;">**Comparable**</span><span style="color:#ff7e7e;">, dvs. sammenligning med et annet </span><span style="color:#ff7e7e;">**Course**</span><span style="color:#ff7e7e;">-objekt, s√• kan </span><span style="color:#ff7e7e;">**Collections.sort**</span><span style="color:#ff7e7e;">- og </span><span style="color:#ff7e7e;">**List.sort**</span><span style="color:#ff7e7e;">-metodene brukes til sortering av </span><span style="color:#ff7e7e;">**Course**</span><span style="color:#ff7e7e;">-objekter.</span>
<span style="color:#ff7e7e;">**Exam**</span><span style="color:#ff7e7e;">-objekter skal ogs√• kunne sorteres, men p√• </span><span style="color:#ff7e7e;">**to m√•ter**</span><span style="color:#ff7e7e;">! Hvordan begge sorteringene kan st√∏ttes og skriv n√∏dvendig kode : I tillegg til </span><span style="color:#ff7e7e;">**Comparable**</span><span style="color:#ff7e7e;">, som bygger sorteringsrekkef√∏lgen inn i klassen selv, s√• kan en implementere en </span><span style="color:#ff7e7e;">**Comparator<Exam>**&lt;/span&gt;<span style="color:#ff7e7e;">, som er en annen klasse som sammenligne to </span><span style="color:#ff7e7e;">**Exam**</span><span style="color:#ff7e7e;">-objekter:</span>
<span style="color:#ff7e7e;">**Table**</span><span style="color:#ff7e7e;"> m√• implementere </span><span style="color:#ff7e7e;">**Comparable&lt;Table&gt;**</span><span style="color:#ff7e7e;"> for at </span><span style="color:#ff7e7e;">**sort**</span><span style="color:#ff7e7e;">-metoden skal kunne brukes og virke. Alternativt kan man lage en (implementasjon av) </span><span style="color:#ff7e7e;">**Comparator&lt;Table&gt;**</span><span style="color:#ff7e7e;">, f.eks. med </span><span style="color:#ff7e7e;">**(t1,t2) -&gt; t1.getCapacity() ‚Äì t2.other.getCapacity()**</span><span style="color:#ff7e7e;">.</span>
IO med byte- og tegnstr√∏mmer **(InputStream/OutputStream** og**Reader/Writer** med subklasser) og filer</Exam></span></T></T></li>
  <li><span style="color:#ff7e7e;"><strong>InputStream</strong></span><span style="color:#ff7e7e;">-/</span><span style="color:#ff7e7e;"><strong>OutputStream</strong></span><span style="color:#ff7e7e;">-klassene h√•ndterer </span><span style="color:#ff7e7e;"><strong>byte</strong></span><span style="color:#ff7e7e;">-verdier, mens </span><span style="color:#ff7e7e;"><strong>Reader</strong></span><span style="color:#ff7e7e;">-/</span><span style="color:#ff7e7e;"><strong>Writer</strong></span><span style="color:#ff7e7e;">-klassene h√•ndterer char-verdier (dvs. implementerer koding av tegn til/fra bytes iht. Unicode-regler).</span></li>
  <li><span style="color:#ff7e7e;">Input/output-metoder kaster ofte </span><span style="color:#ff7e7e;"><strong>IOException</strong></span><span style="color:#ff7e7e;">, som er en s√•kalt ‚Äúchecked exception‚Äù. Slike brukes gjerne for feil som er utenfor v√•r kontroll. Disse krever at kode m√• fange dem opp med </span><span style="color:#ff7e7e;"><strong>try/catch</strong></span><span style="color:#ff7e7e;"> eller deklarere med </span><span style="color:#ff7e7e;"><strong>throws</strong></span><span style="color:#ff7e7e;"> at de kastes videre.</span></li>
  <li><span style="color:#ff7e7e;">Str√∏mmer bruker gjerne ressurser utenfor Java og </span><span style="color:#ff7e7e;"><strong>close()</strong></span><span style="color:#ff7e7e;">-metoden sikrer at Java samhandler riktig med disse, f.eks. frigj√∏r dem. For √• sikre at dette alltid skjer, er det vanlig √• ha </span><span style="color:#ff7e7e;"><strong>close()</strong></span><span style="color:#ff7e7e;">-kallet i en </span><span style="color:#ff7e7e;"><strong>try/finally</strong></span><span style="color:#ff7e7e;">-blokk.</span>
    <h1 id="streams">Streams</h1>
    <p><span style="color:#ff7e7e;">return allBikes.stream().filter(bike -&gt; bike.getRenter() == null &amp;&amp; bike.getLocation().distance(location) &lt;= distance).count();</span></p>
  </li>
</ul>

<p><span style="color:#ff7e7e;">return allBikes.stream().filter(bike -&gt; bike.getRenter() != null).collect(Collectors.toList());</span></p>

<p><span style="color:#ff7e7e;">getRentedBikes().stream().filter(bike -&gt; getStationNearby(bike, 30.0) != null).collect(Collectors.toList());</span></p>

<p><span style="color:#ff7e7e;">diceCol.stream().map(Dice::getScore).reduce(0, (n1, n2) -&gt; n1 + n2)</span></p>

<p><span style="color:#ff7e7e;">diceCol.stream().mapToInt(Dice::getScore).sum()</span></p>

<h1 id="inputoutput-io">Input/Output (IO)</h1>
<p><span style="color:#ff7e7e;">Det viktigste med </span><span style="color:#ff7e7e;"><strong>save</strong></span><span style="color:#ff7e7e;">-metoden er at den f√∏rst skriver ut alle linjer av type 1, alts√• den person-informasjonen som er n√∏dvendig for √• </span><span style="color:#ff7e7e;"><strong>lage</strong></span><span style="color:#ff7e7e;"> Person-objektene f√∏r foreldre-barn-koblingen etableres. Vi velger √• lage en </span><span style="color:#ff7e7e;"><strong>PrintWriter</strong></span><span style="color:#ff7e7e;"> rundt </span><span style="color:#ff7e7e;"><strong>OutputStream</strong></span><span style="color:#ff7e7e;">-en vi f√•r inn, for √• muliggj√∏re bruke av </span><span style="color:#ff7e7e;"><strong>print</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>println</strong></span><span style="color:#ff7e7e;">. Vi kunne brukt en </span><span style="color:#ff7e7e;"><strong>PrintStream</strong></span><span style="color:#ff7e7e;">, men en </span><span style="color:#ff7e7e;"><strong>Writer</strong></span><span style="color:#ff7e7e;"> anbefales jo for tekst (trekker ikke for bruk av </span><span style="color:#ff7e7e;"><strong>PrintStream</strong></span><span style="color:#ff7e7e;">). S√• skrives alle linjene av type 2 ut. Derfor blir det to iterasjoner over alle medlemmene. Navn f√•r anf√∏rselstegn (‚Äù) rundt (merk m√•ten ‚Äù inkluderes i en String). Her sjekkes det om en person har barn (kan gj√∏re p√• mange m√•ter), s√• det ikke blir linjer med en forelder, men det er strengt tatt ikke definert som et krav (det st√•r ‚Äùsequence of names‚Äù, og en sekvens kan jo ha bare ett element). Hvis en har linjer med bare √©n forelder, s√• er det viktig at load-metoden h√•ndterer det riktig. Det er vanlig at den som setter opp en </span><span style="color:#ff7e7e;"><strong>OutputStream</strong></span><span style="color:#ff7e7e;"> ogs√• lukker den, og derfor avslutter vi </span><span style="color:#ff7e7e;"><em>ikke</em></span><span style="color:#ff7e7e;"> med </span><span style="color:#ff7e7e;"><strong>pw.close()</strong></span><span style="color:#ff7e7e;">. Vi avslutter imidlertid med </span><span style="color:#ff7e7e;"><strong>pw.flush()</strong></span><span style="color:#ff7e7e;"> for √• sikre at all v√•r output sendes ut med en gang (trekker ikke for manglende bruk av </span><span style="color:#ff7e7e;"><strong>close()</strong></span><span style="color:#ff7e7e;">/</span><span style="color:#ff7e7e;"><strong>flush()</strong></span><span style="color:#ff7e7e;">).</span>
<span style="color:#ff7e7e;"><strong>load</strong></span><span style="color:#ff7e7e;">-metoden klassifiserer hver linje som en av de tre typene ved √• f√∏rst sjekke om den er tom eller starter med # (type 3) og s√• sjekker om f√∏rste token i en linje er en gyldig </span><span style="color:#ff7e7e;"><strong>Gender</strong></span><span style="color:#ff7e7e;"> (type 1). Ellers er den av type 2. Her gj√∏res det ingen sjekk p√• om formatet er korrekt, f.eks. om et barn i en linje av type 2 faktisk er registrert som familiemedlem. Det er kanskje litt uklart hvorvidt og evt. hvordan </span><span style="color:#ff7e7e;"><strong>tokenize</strong></span><span style="color:#ff7e7e;"> h√•ndterer </span><span style="color:#ff7e7e;"><strong>#</strong></span><span style="color:#ff7e7e;">, s√• det er greit at den brukes f√∏r en sjekker for linjer av type 3.</span>
<span style="color:#ff7e7e;">Unntak h√•ndteres ikke av metodene, s√• de m√• deklareres med </span><span style="color:#ff7e7e;"><strong>throws</strong></span><span style="color:#ff7e7e;">. Det er naturlig √• bruke </span><span style="color:#ff7e7e;"><strong>IOException</strong></span><span style="color:#ff7e7e;">, for den utl√∏ses ved bruk av </span><span style="color:#ff7e7e;"><strong>InputStream</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>OutputStream</strong></span><span style="color:#ff7e7e;">. En kunne brukt </span><span style="color:#ff7e7e;"><strong>Exception</strong></span><span style="color:#ff7e7e;"> or √• markere (at vi er klar over) at det er mye som kan g√• galt, men det anbefales √• bruke den mest spesifikke typen. Vi kunne fanget opp og ignorert unntak, men det kan lett maskere feil vi √∏nsker √• avdekke.</span>
<span style="color:#ff7e7e;"><strong>public void save(OutputStream out) throws IOException {</strong></span>
<span style="color:#ff7e7e;"><strong>PrintWriter pw = new PrintWriter(out);</strong></span>
<span style="color:#ff7e7e;"><strong>‚Ä¶</strong></span>
<span style="color:#ff7e7e;"><strong>pw.flush()</strong></span>
<span style="color:#ff7e7e;"><strong>}
public void load(InputStream in) throws IOException {</strong></span>
<span style="color:#ff7e7e;"><strong>Scanner scanner = new Scanner(in);</strong></span>
<span style="color:#ff7e7e;"><strong>‚Ä¶</strong></span>
<span style="color:#ff7e7e;"><strong>scanner.close();</strong></span>
<span style="color:#ff7e7e;"><strong>}</strong></span></p>
<h1 id="fxml">FXML</h1>
<p><span style="color:#ff7e7e;">Av FXML-koden kan en lese at det grafiske grensesnittet (appen) knyttes til </span><span style="color:#ff7e7e;"><strong>BikeRental</strong></span><span style="color:#ff7e7e;"> ved hjelp av klassen </span><span style="color:#ff7e7e;"><strong>BikeRentalController</strong></span><span style="color:#ff7e7e;">. Dette er i tr√•d med navnekonvensjonene brukt i tidligere eksamener. Det refereres til to tekstfelt som en i koden kobler seg til med henholdsvis  @FXML private TextField </span><span style="color:#ff7e7e;"><strong>fromInput</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>toInput</strong></span><span style="color:#ff7e7e;">. Likeledes m√• en lage tre metoder (@FXML private void </span><span style="color:#ff7e7e;"><strong>plus1HourAction</strong></span><span style="color:#ff7e7e;">, </span><span style="color:#ff7e7e;"><strong>minus1HourAction</strong></span><span style="color:#ff7e7e;"> og </span><span style="color:#ff7e7e;"><strong>rentAction</strong></span><span style="color:#ff7e7e;">) som kalles n√•r knappene i grensesnittet trykkes inn.</span>
<span style="color:#ff7e7e;">Her er vi mest opptatt av:
	- @FXML-annotasjonene
	- riktig type og navn for variablene og metoden
	- at en henter input fra </span><span style="color:#ff7e7e;"><strong>dieCountInput</strong></span><span style="color:#ff7e7e;"> og setter output med </span><span style="color:#ff7e7e;"><strong>diceOutput</strong></span></p>

<h1 id="diagrammer">Diagrammer</h1>
<p>Grovt sett beskriver diagrammer to ulike aspekter ved et program:</p>
<ol>
  <li>Tilstand/oppf√∏rsel ved kj√∏retid, alts√• hva som skjer n√•r programmet kj√∏res, f.eks. tilstanden til objektstrukturer. Eksempler er <a href="https://www.ntnu.no/wiki/display/tdt4100/Objektdiagrammer"><strong>Objektdiagrammer</strong></a>, <a href="https://www.ntnu.no/wiki/display/tdt4100/Objekttilstandsdiagrammer"><strong>Objekttilstandsdiagrammer</strong></a> og <a href="https://www.ntnu.no/wiki/display/tdt4100/Sekvensdiagrammer"><strong>Sekvensdiagrammer</strong></a>.</li>
  <li>Design, alts√• hvordan programkoden er strukturert, f.eks. hvilke klasser som finnes og hvordan de henger sammen. <a href="https://www.ntnu.no/wiki/display/tdt4100/Klassediagrammer"><strong>Klassediagrammer</strong></a> er et eksempel.</li>
</ol>

<p>PLANTUML</p>
<ul>
  <li>Hide circle : hides class/interface/abstract icon</li>
</ul>

<p><span style="color:#ff7e7e;">De ulike diagramdelene, alts√• boksene, strekene/pilene og tegnene (ord, tall og <em>):
Diagrammet er omtrent som et klassediagram, s√• boksene tilsvarer klasser. Navnet √∏verst en boks er klassenavnet, mens de andre er egenskaper, dvs. data, som instansene vil ha. Strekene er assosiasjoner (eller relasjoner), som sier noe om hvordan instanser kan kobles sammen. Tallene p√• enden av strekene angir hvor mange koblinger en instans kan ha (</em> betyr ubegrenset), s√•kalt </span><span style="color:#ff7e7e;"><em>multiplisitet</em></span><span style="color:#ff7e7e;">. Pilene sier noe om i hvilken retning en kan f√∏lge en kobling, ingen betyr begge retninger, mens √©n pil betyr bare i den retningen.
Egenskapene og assosiasjonene blir typisk til felt med type som passer til multiplisiteten. En m√• velge hvordan dataene skal </span><span style="color:#ff7e7e;"><em>kapsles inn</em></span><span style="color:#ff7e7e;">, alts√• konstrukt√∏rer med parametre, gettere og settere, og evt. add- og remove-metoder og andre metoder.</span></p>

<p><strong>Objektdiagrammer (objekter med tilstand og koblinger)</strong>
er en diagramtype som viser tilstanden til et program, ved √• illustrere ‚Äúsnapshots‚Äù av objektstrukturer. 
Hva er forskjellen (hensikt og innhold) mellom <em>objektdiagrammer</em> og <em>objekttilstandsdiagrammer</em>?
<span style="color:#ff7e7e;">Et </span><span style="color:#ff7e7e;"><em>objektdiagram</em></span><span style="color:#ff7e7e;"> viser oppbygning av og koblinger mellom objekter/instanser, og brukes for √• illustrere tilstanden til (eller en mulig tilstand til) et program. Et </span><span style="color:#ff7e7e;"><em>objekttilstandsdiagram</em></span><span style="color:#ff7e7e;"> viser hvordan slike strukturer endres over tid, ved kall av metoder (typisk endringsmetoder), og brukes til √• illustrere (mulig) objektoppf√∏rsel og utviklingen av tilstanden til et program.</span></p>

<p><strong>Objekttilstandsdiagrammer</strong>
Hvis en tenker p√• objektdiagrammer som tilstander og kobler dem sammen med transisjoner, s√• f√•r en objekttilstandsdiagram, som viser hvordan objektstrukturer utvikler seg over tid.
<span style="color:#ff7e7e;">Objekttilstandsdiagrammer brukes til √• beskrive oppf√∏rselen til et objekt. Viktig fordel og ulempe/begrensning.</span></p>
<ul>
  <li><span style="color:#ff7e7e;"><strong>Fordeler</strong></span><span style="color:#ff7e7e;">: Eksempel p√• forl√∏p kan v√¶re enklere √• forst√• enn en komplett definisjon i form av regler (invarianter). Diagrammer kan v√¶re mer intuitive enn tekst. Det er lett √• skrive test-kode basert p√• diagrammet.</span></li>
  <li><span style="color:#ff7e7e;"><strong>Ulemper</strong></span><span style="color:#ff7e7e;">: Diagrammene blir lett store, hvis de skal dekke alle relevante tilfeller. Det er kun i enkle tilfeller en kan beskrive oppf√∏rselen komplett.</span>
<img src="https://lh3.googleusercontent.com/BdQk0vES-NcOPFM-RtR9Vn6ndD65mJqTQ5RS8NA7Pkpv8RXNbFYWUvKUfLrjc_-x-XSQw06IOdGKUWewm7Sze9M9sFCzwr4ow1JIKFfvNz9gm5DLkPd7EMKE6RwOmcnsJlGvngrdGd0TGftfYA" alt="" />
<strong>Sekvensdiagrammer</strong>
Interaksjonsdiagrammer viser hvordan objekter i en objektstruktur bruker hverandre, dvs. kaller hverandres metoder. Det finnes to varianter: samhandlingsdiagrammer utvider objektdiagrammer med visning av (sekvenser av) metodekall, og sekvensdiagrammer viser metodekall mellom objekter langs en tidslinje.</li>
</ul>

<p><strong>Klassediagrammer (klasser og assosiasjoner inkl. kardinalitet)</strong>
viser klassestrukturen til et program, med innholdet i klasser (attributter og operasjoner) og hvordan de er koblet sammen med arv og assosiasjoner.</p>

:ET