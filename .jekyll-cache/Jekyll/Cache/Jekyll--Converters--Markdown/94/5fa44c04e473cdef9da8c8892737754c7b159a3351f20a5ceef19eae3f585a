I"&≈<h1 id="innkapsling-og-validering---teorisp√∏rsm√•l">Innkapsling og validering - Teorisp√∏rsm√•l</h1>

<ol>
  <li>
    <p>a) Hva er forskjellen p√• <strong>public</strong>, <strong>protected</strong> og <strong>private</strong>?
<strong>public</strong> brukes n√•r andre klasser skal kunne instansiere klassen direkte med **new <klasse>(‚Ä¶)**. **protected**-konstrukt√∏rer brukes for √• initialisere felt i en superklasse og kalles av subklassens konstrukt√∏r med **super(‚Ä¶)**. **private** brukes p√• hjelpekonstrukt√∏rer internt i en klasse og kalles med **this(‚Ä¶)**.
b) Hva b√∏r i utgangspunktet alle variablene dine v√¶re deklarert som? 
Innkapsling handler om √•: 
1) hindre at en kan sette objekter til en ulovlig tilstand og 
2) skjule representasjonsdetaljer slik at en kan gj√∏re endringer uten at andre klasser ogs√• m√• endres.</klasse></p>
  </li>
  <li>
    <p>Hvilke to metoder er vanlig √• ha for variabler i Java? 
Generelt er det en fordel √• redusere settet med metoder, siden det gir frihet til √• endre klasse siden. N√•r felt initaliseres i en konstrukt√∏r, s√• trengs som oftest ikke set-metoder. Her trenger en heller ikke get-metoder, siden metodene som stiller sp√∏rsm√•l og sjekker svar utgj√∏r et komplett API for klassen.</p>
  </li>
</ol>

<p>get-metoder gir tilgang til tilstanden uten √• ‚Äúavsl√∏re‚Äù hvilke felt som brukes for √• representere tilstanden.</p>

<ol>
  <li>
    <p>Hva er forskjellen p√• ugyldig tilstand og ugyldig argument? 
Hva er form√•let med / begrunnelsen for √• implementere en eller flere konstrukt√∏rer for en klasse : En konstrukt√∏r har som form√•l √• *initialisere *et objekt, slik at det fra starten av har en *gyldig *tilstand.</p>
  </li>
  <li>
    <p>Hva er meningen med innkapsling og validering? 
Innkapsling skal sikre et objekt starter og forblir i en <em>gyldig tilstand</em> og at innholdet kan leses og endres uten √• avdekke den <em>interne representasjonen og implementasjonen</em>. Mekanismen er bruk av synlighetsmodifikatorer, som reduserer muligheten (andre) klasser har til √• referere til felt og metoder.</p>
  </li>
</ol>

<p>En kan kategorisere innkapslingsmetoder som enten lese- eller endringsmetoder. Den viktigste oppgaven til endringsmetodene, bortsett fra √• utf√∏re selve endringen er √• sjekke (validere) om den nye verdien (eller nye verdiene) er lovlige/gyldige, f√∏r de evt. endres, f.eks. at et navn kun inneholder bokstaver og mellomrom.</p>

<ol>
  <li>Trenger man √• validere argumenter som tas inn i konstrukt√∏ren?</li>
</ol>

<p><strong>public final int hours, minutes;
final</strong> betyr her at feltet ikke kan endres <em>etter</em> at det er satt i konstrukt√∏ren. Selv om feltene er <strong>public</strong> s√• sikres innkapsling ved at felt-verdiene forblir korrekte, siden kode utenfor klassen ikke kan sette feltene til ugyldige verdier Imidlertid er det ikke i tr√•d med innkapsling at kode gj√∏res avhengig av at data er lagret i spesifikke felt. Ved bruk av get-metoder f√•r implementasjonsklassen st√∏rre frihet til √• endre interne detaljer, uten at annen kode blir p√•virket.</p>

<p><strong>final</strong> betyr her at feltet ikke skal kunne endres etter at det er initialisert. Da m√• en enten initialisere i deklarasjonen eller i en eller flere konstrukt√∏rer, eller en kombinasjon.</p>

<p>Klasser utformet slik at instanser ikke skal kunne endres etter at de er opprettet, <em>generelle</em> fordeler og ulemper med klasser som gir ikke-modifiserbare (immutable) instanser er at klassen blir enklere, og minsker bl.a. behovet for validering. Instanser kan brukes av flere deler av et program, uten risiko for at en del endrer p√• dem og √∏delegger for en annen del. Ulempen er at en m√• lage nye instanser hvis de m√• rettes p√•, istedenfor √• endre dem direkte.</p>

<p>Den generelle teknikken og navnekonvensjonen(e) for √• representere og kapsle inn en enkel verdi, f.eks. tall eller objektreferanse, som skal kunne endres etter at objektet er opprettet:
<strong>private T value;
public T getValue() { ‚Ä¶ }
**(Dersom X er boolean/Boolean, s√• brukes gjerne ‚Äúis‚Äù som prefiks istedenfor ‚Äùget‚Äù).
**public void setValue(T value) { ‚Ä¶ }</strong></p>

<p>Med static-modifikatoren vil metodene ikke kunne referere til et bestemt RadioAlphabet-objekt. En kan for s√• vidt gj√∏re alfabetet static ogs√•, men da vil en bare kunne ha ett globalt alfabet.
En metode kan v√¶re <strong>static</strong> siden den ikke bruker felt eller metoder som er ikke-<strong>static</strong>.</p>

<p>I forhold til innkapsling, hovedgrunnen til √• la en konstrukt√∏r ta en eller flere parametre : Parametrene til en konstrukt√∏r er informasjon som trengs for √• gi objektet en gyldig starttilstand, som oftest verdien til felt som m√• v√¶re satt og det ikke finnes noen fornuftig default-verdi.</p>

<p>Java ved gitte forutsetninger vil automatisk opprette en konstrukt√∏r for en klasse, slik at instanser av klassen kan opprettes, selv om en ikke eksplisitt har definert en konstrukt√∏r for klassen. Betingelsen(e) for at Java skal gj√∏re dette : Forutsetningen for √• automatisk opprette en konstrukt√∏r er at den er instansierbare dvs. ikke abstrakt, og det ikke er definert noen andre konstrukt√∏rer. En slik konstrukt√∏r vil v√¶re <strong>public</strong> og ha tom parameterliste.</p>

<p>En annen teknikk for initialisering enn deklarasjon er √• bruke en eller flere konstrukt√∏rer. Dette er metoder med samme navn som klassen som blir implisitt kalt ved bruk av new (med eller uten argumenter). Fordeler:
	- en kan skrive mer komplisert kode for initialisering, med f.eks. valg og validering
	- en kan (tvinges til √•) oppgi argumenter som kan brukes i initialiseringen
	- konstrukt√∏rer hjelper en √• sikre tilstand ved bruk av innkapsling
Ulemper:
	- koden for initialisering blir ofte langt unna feltene den initialiserer
	- det er lett √• glemme √• initialisere felt</p>

<p>Dette handler om<a href="https://www.ntnu.no/wiki/display/tdt4100/Innkapsling"> innkapsling</a>, som har to aspekter: 1) sikring av gyldig tilstand og 2) skjuling av implementasjonsdetaljer, s√• koden lettere kan endres uten at andre klasser p√•virkes. Av disse to er aspekt 1) viktigst.</p>

<p>Den f√∏rste teknikken krever mindre kode og er derfor enklere √• lese og skrive. Siden en bruker <strong>final</strong>-modifikatoren s√• sikres aspekt 1), siden verdiene/tilstanden ikke kan endres tross at feltet er <strong>public</strong>. Imidlertid s√• er det andre aspektet ved innkapsling ikke ivaretatt, siden feltet er eksponert. Derfor er den andre teknikken √• foretrekke, som ivaretar begge aspektene.</p>

<p>Objekter som ikke kan endres, kan deles/brukes i flere datastrukturer uten fare for kluss. Hvis delte objekter kan endres, s√• m√• en v√¶re mer n√∏ye p√• hva en gj√∏r.</p>

<p>finne passende datastruktur og innkapslingsmetoder. En trenger bare √©n add-metode, selv om det er vist to har. For √• g√• gjennom segmentene trenger en b√•de √©n metode for <strong>count/size</strong> (ellers vet en ikke n√•r iterasjonen skal stoppe) og √©n for √• hente ut et element.
Det var veldig mange som lurte p√• formuleringen ‚Äúg√• gjennom dem basert p√• indeks‚Äù, antageligvis fordi det ikke var sagt at dette var <em>innkapsling for andre klasser</em>, ikke til bruk internt i klassen.</p>

<h1 id="grensesnittinterface---teorisp√∏rsm√•l">Grensesnitt/Interface - Teorisp√∏rsm√•l</h1>

<ol>
  <li>
    <p>Hvilket n√∏kkelord i Java brukes for √• angi at en klasse implementerer et grensesnitt?</p>
  </li>
  <li>
    <p>Hva er forskjellen p√• en klasse og et grensesnitt?</p>
  </li>
  <li>
    <p>Nevn tre bruksomr√•der hvor det er en fordel √• bruke grensesnitt.</p>
  </li>
  <li>
    <p>Kan grensesnitt definere private metoder?</p>

    <ol>
      <li>Hvorfor gir/gir ikke dette mening?</li>
    </ol>
  </li>
  <li>
    <p>Kan et grensesnitt implementere et annet grensesnitt?</p>
  </li>
  <li>
    <p>Kan et grensesnitt arve et annet grensesnitt?</p>
  </li>
  <li>
    <p>Hva er forskjellen p√• √• implementere et grensesnitt og √• arve fra en annen klasse?</p>
  </li>
  <li>
    <p>Hva er forskjellen p√• en abstrakt klasse og et grensesnitt?</p>

    <ol>
      <li>Hvilke muligheter har man i en abstrakt klasse som man ikke har i et grensesnitt?</li>
    </ol>
  </li>
  <li>
    <p>Definer (skriv ned) et grensesnitt etter hukommelsen.</p>
  </li>
  <li>
    <p>Kan et grensesnitt inneholde variabler?</p>

    <ol>
      <li>Hva m√• eventuelt en variabel deklareres som for √• v√¶re tillatt i et grensesnitt?</li>
    </ol>
  </li>
  <li>
    <p>Kan et grensesnitt definere konstrukt√∏rer?</p>
  </li>
</ol>

<p>Et grensesnitt skal ikke ha konstrukt√∏rer og statiske metoder. Det er faktisk lov √• ha statiske metoder i grensesnitt i Java, men det h√∏rer ikke med i objektorientert tenkning.</p>

<p>Dice-grensesnittet *m√• *utvide (extends) Iterable<Integer> *og kan *liste opp metoden(e) fra Iterable. for et grensesnitt kan gjenta metoder fra et grensesnitt det utvider, men m√• ikke.</Integer></p>

<h1 id="arv---teorisp√∏rsm√•l">Arv - Teorisp√∏rsm√•l</h1>

<ol>
  <li>
    <p>Hva er forskjellen p√• en abstrakt klasse og et grensesnitt?
En abstrakt klasse er en klasse som ikke kan instansieres, enten fordi den er ufullstendig ved at den deklarerer √©n eller flere abstrakte (tomme) metoder, eller fordi det ikke gir mening. Ingen av de tre klassene b√∏r v√¶re abstrakte, siden alle er fullstendige og implementerer en nyttig relasjon.</p>
  </li>
  <li>
    <p>Hvilke krav m√• en subklasse oppfylle for at det skal v√¶re naturlig for den √• arve fra en superklasse?</p>
  </li>
  <li>
    <p>Hvilket n√∏kkelord brukes for √• arve fra en annen klasse i Java?</p>
  </li>
  <li>
    <p>Hvor mange klasser kan en subklasse arve fra?</p>
  </li>
  <li>
    <p>Du har tre klasser: Human, Person og Student. Student arver fra Person, og Person arver fra Human. Du lager et objekt av hver klasse: human, person, student.</p>

    <ol>
      <li>
        <p>Har student tilgang til feltene og metodene i Human?</p>
      </li>
      <li>
        <p>Hva vil ‚Äúhuman instanceof Student‚Äù returnere?</p>
      </li>
      <li>
        <p>Hva vil ‚Äústudent instanceof Human‚Äù returnere?</p>
      </li>
    </ol>
  </li>
  <li>
    <p>N√•r en subklasse arver fra en superklasse, f√•r den tilgang til konstrukt√∏rene til superklassen?</p>

    <ol>
      <li>N√•r f√•r den eventuelt (ikke) det?</li>
    </ol>
  </li>
  <li>
    <p>Forklar hvordan bruk av protected-felt/metoder fungerer ved arv.</p>
  </li>
  <li>
    <p>Kan man instansiere en abstrakt klasse?
2 klasser har en del felles egenskaper, som kan samles i en felles superklasse kalt <strong>MenuItem</strong>:
Her er poenget √• samle det som er felles. Klassen b√∏r v√¶re abstract, siden det ikke gir mening √• instansere den.</p>
  </li>
  <li>
    <p>Er det n√∏dvendig √• bruke annotasjonen @Override n√•r man redefinerer en arvet metode?</p>
  </li>
  <li>
    <p>Du har arvet en metode fra en superklasse og redefinert den i din egen klasse. Hvordan kan man bruke metoden som var definert i superklassen?</p>
  </li>
  <li>
    <p>Du skriver din egen konstrukt√∏r i en subklasse, men √∏nsker √• kalle superklassens konstrukt√∏r for √• slippe √• kopiere kode. Hvordan gj√∏r du dette?</p>
  </li>
</ol>

<ul>
  <li>N√•r en arver s√• kan en ikke kun arve de metodene en √∏nsker, men f√•r alle med p√• kj√∏pet. Da vil en v√¶re n√∏dt til √• redefinere alle en ikke trenger/√∏nsker at skal v√¶re tilgjengelig.</li>
  <li>Det vil ikke alltid v√¶re logisk riktig at klassen skal v√¶re **instanceof List<X>**</X></li>
  <li>(Teknikken kan bare brukes for √©n slik liste, siden en bare kan arve fra √©n implementasjonsklasse).</li>
</ul>

<p><strong>super()</strong> kaller konstrukt√∏ren i superklassen og trengs for √• sikre at ogs√• superklassens konstrukt√∏r blir kj√∏rt. Her er super-klassen implisitt Object-klassen. Hvis linja ikke er med, s√• vil et tilsvarende kall, alts√• til en konstrukt√∏r uten argumenter, bli lagt til av kompilatoren. Derfor kan vi trygt fjerne linja.</p>

<p>Poenget her at siden <strong>Course</strong> og <strong>Meal</strong> n√• har en felles superklasse, s√• blir det enklere √• ha datastrukturer med begge disse objekttypene i. Dette forenkler b√•de <strong>Menu</strong>- og <strong>Table</strong>-klassene. En blir her bedt om √• skrive mye kode p√• nytt, og siden eksamen var digital, s√• b√∏r det v√¶re greit i praksis. Det er greit √• bare skrive de delene som blir endret, til n√∏d forklare endringene med tekst.</p>

<p>Det disse tre implementasjonene har felles er <strong>score</strong>-verdien, s√• denne kan legges i den abstrakte <strong>AbstractScorer</strong>-klassen, initialiseres ved √• kalle <strong>super(score)</strong> √∏verst i subklasse-konstrukt√∏rene og leses med <strong>getScore()</strong>:</p>

<p>En antar at det finnes ulike klasser for ulike typer fremkomstmidler en kan leie. Hver type skal kunne ha sine egne sett med verdier brukt til prising, f.eks. pris pr. time og pris pr. Tidsforlengelse. Hvordan arvingsmekanismen kan benyttes?</p>
<ul>
  <li>Det naturlige er da √• lage en abstrakt klasse <strong>Vehicle</strong> som inneholder priselementer (pris per time, forsentbot etc) og gettere/settere (som <strong>getHourRate</strong>, <strong>setLocation</strong> m.m). Ikke alle av disse trenger √• v√¶re abstrakte, eksempelvis kan det som har med lokasjon √• gj√∏re v√¶re implementert i Vehicle. Alle fremkomstmidler (<strong>Bike</strong>, <strong>Hoverboard</strong> og slikt) og m√• s√• arve denne klassen og kan redefinere metoder for √• endre verdiene/logikken som brukes i prisberegningen. Der en i <strong>BikeRental</strong> (som egentlig burde skifte navn til <strong>VehicleRental</strong>) refererer til <strong>Bike</strong> m√• en n√• i stedet referere til den abstrakte klassen <strong>Vehicle</strong>.</li>
</ul>

<p>Vi lager en abstrakt klasse basert p√• Trip og gj√∏r estimateTime abstract:
S√• lar vi Trip arve fra denne og implementere estimateTime som over.
Andre varianter (interface) vil gj√∏re det samme, men implementere estimateTime med annen logikk. Det er strengt tatt ikke n√∏dvendig √• ha en abstrakt klasse, en kan alternativt bare arve fra Trip.</p>

<p><strong>SimpleTable</strong> og <strong>CompositeTable</strong> blir subklasser av Table, som selv enten blir et grensesnitt eller en abstrakt klasse med i hvertfall <strong>getCapacity</strong>-metoden. De to variantene er vist under. <strong>SimpleTable</strong> kan ta over det meste av <strong>Table</strong>-koden, evt. arve alt. <strong>CompositeTable</strong> kapsler inn informasjonen fra <strong>mergeTable</strong> og bruker de to <strong>Table</strong>-objektene til √• beregne kapasiteten. Alternativt kan <strong>Table</strong> beholde <strong>capacity</strong>-feltet og <strong>getCapacity()</strong>-metoden og de to andre initialiserer <strong>capacity</strong> med <strong>super(‚Ä¶)</strong>. Vi har her ikke lagt opp til at <strong>CompositeTable</strong>-objekter skal f√• et l√∏penummer, men det er greit √• la den funksjonaliteten v√¶re en del av en abstract <strong>Table</strong>-(super)klasse.</p>

<p>Her er poenget √• skille ut det som har med <strong>score</strong> √• gj√∏re i en abstrakt superklasse, nemlig feltet <strong>score</strong>, (den delen av) konstrukt√∏ren som tar inn og setter <strong>score</strong> og <strong>getScore</strong> og <strong>setScore</strong>. Dette er viktigst.</p>
<ul>
  <li>Hvis en lar den abstrakte superklassen implementere Dice-grensesnittet evt. deklarer en del av Dice sine metoder som abstrakte metoder, s√• kan enda flere metoder implementeres, f.eks. trenger toString og getValueCount bare getDieCount og getDieValue. En trenger ikke implementere disse, men forklare at det g√•r an og vil v√¶re lurt.</li>
</ul>

<h1 id="delegering---teorisp√∏rsm√•l">Delegering - Teorisp√∏rsm√•l</h1>

<ol>
  <li>
    <p>Forklar forholdet mellom en delegat og en delegerende.
<a href="https://www.ntnu.no/wiki/display/tdt4100/Delegeringsteknikken">Delegeringsteknikken</a> i praksis, hvor en instans av (en implementasjon av) et grensesnitt bruker en eller flere andre instanser av (implementasjoner av) samme grensesnitt, til √• gj√∏re jobben.</p>
  </li>
  <li>
    <p>I et firma med en Manager og flere Coworkers, hvem er naturlig de(n) delegerende og hvem er delegat(er)?</p>
  </li>
  <li>
    <p>Forklar hvordan det kan v√¶re nyttig √• benytte grensesnitt i forbindelse med delegering.</p>

    <ol>
      <li>Ved √• benytte grensesnitt for en delegat-klasse, hvilke fordeler f√•r man?</li>
    </ol>
  </li>
  <li>
    <p>N√•r kan det v√¶re smart √• benytte delegeringsteknikken fremfor arv?</p>
  </li>
</ol>

<p>Delegering er en teknikk hvor et objekt, videreformidler kall til en ‚Äúdelegat‚Äù n√•r det er behov for delegatens ferdigheter. I dette tilfellet er det viktig at TimeSlot-objektene som ligger i delegaten regnes med i logikken. F.eks. m√• <strong>getTimeSlotAt(‚Ä¶)</strong>-metoden sjekke egne TimeSlot-objekter og delegatens og returnere det tidligste av de to.</p>

<p>I del 2 ble utregning av kostnad ‚Äòhardkodet‚Äô inn i <strong>rentBike</strong>. Hvis man skal st√∏tte utregning av kostnader ved hjelp av delegering, s√• m√• man lage et grensesnitt (interface) som inneholder en metode for beregning av pris. I LF har vi laget grensesnittet <strong>PricePolicy</strong>, som blir implementert av klassen <strong>DefaultPricePolicy</strong>. I del 2 ble all beregning gjort i en egen hjelpemetode, <strong>computePrice</strong>. Det er derfor helt greit at grensesnittet inneholder nettopp denne metoden. I <strong>BikeRental</strong> m√• en s√• opprette et <strong>DefaultPricePolicy</strong>-objekt, og kalle dennes <strong>computePrice</strong> for √• beregne pris. Hvis en vil bruke en annen prisingslogikk, s√• bruker man bare en annen implementasjon.</p>

<p>en kan ogs√• bruke delegering for √• tilby <em>individuell</em> prising (alts√• pr. <strong>Person</strong>), f.eks. Bonus-ordninger: I 3a ble det lagt opp til delegering av kostnadsberegning, men dette var ikke knyttet til enkeltpersoner. For √• implementere individuell prising kan en heller lage et sett med ulike <strong>PricePolicy</strong>, (studenter, barn, voksne etc.) og knyttet disse til <strong>Person</strong>-objektet (med gettere og settere). N√•r <strong>rentBike</strong> skal beregne kostnad m√• en s√• delegere til <strong>Person</strong>-objektet (som igjen ligger i <strong>Bike</strong>) sin <strong>PricePolicy</strong>.</p>

<p>Delegeringsteknikken er mer fleksibel enn arv, fordi en n√•r som helst kan bytte ut TimeEstimator-objektet og dermed ogs√• endre oppf√∏rselen til estimateTime-metoden. Arv-mekanismen frigj√∏res dessuten til andre mer ‚Äúverdige‚Äù form√•l.</p>

<p>Poenget her er √• gj√∏re som beskrevet i oppgaven, √• bruke <strong>rel2</strong> p√• resultatet av √• bruke <strong>rel1</strong>. Her sjekkes det ikke for duplikater (som det sjelden er behov for med relasjoner av denne typen). Dette er <em>delegeringsteknikken</em> i praksis, som kjennetegnes ved at et <em>delegerende</em> objekt, som skal utf√∏re en oppgave, ber en eller flere <em>delegater</em> om √• utf√∏re (omtrent) samme oppgave, for s√• √• kombinere resultatene. Her delegeres det til <strong>rel1</strong> og <strong>rel2</strong>, som implementerer samme grensesnitt som <strong>Relation2</strong>.</p>

<h1 id="observat√∏r-observert-teknikken---teorisp√∏rsm√•l">Observat√∏r-observert-teknikken - Teorisp√∏rsm√•l</h1>

<ol>
  <li>
    <p>P√• hvilken m√•te kan observat√∏r-observert-teknikken hjelpe til √• holde tilstanden i et program konsistent?
Observat√∏r-observert-teknikken brukes n√•r en eller flere objekter, her kalt observat√∏rer, m√• holdes konsistent med et annet objekt, her kalt observert, og det observerte objektet sin implementasjon ikke skal v√¶re for tett knyttet til observat√∏renes. Teknikken er basert p√• at det observerte objektet sier fra til en eller flere observat√∏rer om at tilstanden er endret, slik at observat√∏rene kan oppdatere sin tilstand ift. deres regler for konsistens.</p>
  </li>
  <li>
    <p>Nevn (minst) tre metoder som burde v√¶re med i de aller fleste implementasjoner av observat√∏r-observert-teknikken.</p>
  </li>
  <li>
    <p>Hvorfor kan det v√¶re lurt √• benytte grensesnitt for den observerte parten i et observat√∏r-observert-forhold?</p>
  </li>
  <li>
    <p>Hvorfor kan det v√¶re lurt √• benytte grensesnitt for observat√∏r-parten i et observat√∏r-observert-forhold?</p>
  </li>
  <li>
    <p>Tenk at en nettside oppdateres jevnlig, og du √∏nsker √• f√• et varsel til mobilen din hver gang nettsiden oppdateres. Hvilken av partene er den observerte og og hvilken er observat√∏r?</p>
  </li>
  <li>
    <p>Hvorfor l√∏nner det seg √• bruke observat√∏r-observert-teknikken fremfor √• jevnlig sjekke om et objekt har endret tilstand?</p>
  </li>
</ol>

<p>Dette er standard bruk av observat√∏r-observert-teknikken, alts√• m√• en ha felt med liste av lyttere, metoder for √• legge til og fjerne lyttere og helst en hjelpemetode for √• varsle dem.</p>

<p>Observat√∏r-observert-teknikken, lytte til endringer. Lytting med 1) et grensesnitt, 2) liste av lyttere, 3) add/remove-metoder for lyttere, 4) metode til lytterne og 5) kall av metode n√•r endring skjer.</p>

<p>Observerbarhet krever:
	1. at en holder styr p√• lytterne og
	2. at alle endringsmetoder kaller lytternes lyttermetode.</p>

<p>Observert-observat√∏r-teknikken brukes til √• f√∏lge med p√• hvordan tilstanden til objekter endres over tid, typisk for √• sikre konsistens med andre objekter, f.eks. et GUI med ‚Äúindre‚Äù objekter. Et objekt er observerbart dersom en kan lese ut alle relevant tilstand og en kan f√• beskjed (lytte p√• hendelser) om n√•r og hvordan denne tilstanden endres.
	Det siste sp√∏rsm√•let er et luresp√∏rsm√•l: Dice er allerede observerbar! Siden tilstanden ikke kan endres, s√• trenger en ikke √• st√∏tte lyttere. Hvis tilstanden kunne endres, s√• m√•tte man 1) definert et lyttergrensesnitt, 2) hatt metoder for √• administrere (registrere og avregistrere) lyttere, 3) hatt metode(r) for √• sende ut varsler om tilstandsendringer og 4) kalt disse metodene i alle metoder som faktisk endrer tilstanden.</p>

<p>Den generelle teknikken er <em>observat√∏r-observert</em>, som b√•de brukes for √• si fra om at tiden g√•r og om at <strong>Trip</strong> er endret. Tiden h√•ndteres ved √• anta at det finnes en <strong>Clock</strong>-klasse, som kan si fra hvert minutt til et sett med lyttere. En kan f.eks. ha grensesnittet <strong>ClockListener</strong> med <strong>minuttPassed()</strong>-metoden og metodene <strong>addClockListener</strong> og <strong>removeClockListener</strong>. <strong>Trip</strong> m√• gj√∏res <em>observerbar</em>: 1) en m√• ha lese-metoder for alle relevante data og 2) en m√• kunne registrere lyttere (som implementerer et lyttergrensesnitt f.eks. kalt <strong>TripChangedListener</strong>) som f√•r beskjed n√•r objektet endres (f.eks. vha. en metode kalt <strong>tripChanged</strong>).</p>

<p>Hva inneb√¶rer observerbarhet? Hvordan en gj√∏r en (egenskap i en) klasse observerbar?</p>
<ul>
  <li>Observerbarhet handler om √• la et eller flere objekter (observat√∏rene/lytterne) f√• beskjed om endringer i et annet objekt (den observerte). Observert-klassen m√• administrere et sett med lyttere (objekter som implementerer et lyttergrensesnitt), vha. felt for Collection av lyttere og add/remove-metoder. Alle steder hvor tilstanden (til egenskapen) endres, m√• det skytes inn kode som sier fra til lytterne (kall p√• fire-metode, som g√•r gjennom lytterne).</li>
  <li>Capacity-egenskapen beregnes p√• bakgrunn av <strong>tables</strong>- og <strong>seatings</strong>-listene, og derfor m√• lytterne varsles hver gang disse endres (av <strong>addTable</strong>, <strong>removeTable</strong>, <strong>addSeating</strong> og <strong>removeSeating</strong>). Det skilles ikke mellom om kapasiteten √∏ker eller minker, selv om det er √∏kning som <strong>GuestManager</strong> er interessert i. Lyttere registreres med <strong>add</strong>/<strong>removeCapacityListener</strong>-metoder og en <strong>fireCapacityChanged</strong>-metode, som varsler lytterne (CapacityListener-implementasjoner), kalles av endringsmetodene.</li>
</ul>

<p>Standardteknikken krever et passende lyttergrensesnitt og en liste av lyttere som kalles p√• passende sted. En bruker gjerne en Collection for √• lagre lytterne og add/remove-metoder for √• administrere lytterne.</p>
<ul>
  <li>LF definerer lyttergrensesnittet <strong>TreatmentListener</strong>. Dette grensesnittet har √©n metode, som kalles idet doktor-pasient-koblingen etableres, alts√• p√• tidspunktet det passer √• gi beskjed til pasienten om hvilken doktor hen skal g√• til. Metoden b√∏r ta inn faktisk pasient, doktor og akuttmottak (<strong>TreatmentUnit</strong>).</li>
  <li>Endringer som m√• gj√∏res i <em>den</em> <em>observerte</em>, <strong>TreatmentUnit</strong>, er at alle lytterne lagres i en <strong>private</strong> <strong>Collection</strong> av type <strong>TreatmentListener</strong>, og at den legger inn relevante <strong>public add/remove</strong> til denne. I tillegg defineres hjelpemetoden <strong>fireTreatmentStarted</strong>, som kalles rett etter at <strong>setPatient</strong> har etablert en ny doktor-pasient-kobling (i b√•de <strong>startTreatment(Doctor)</strong> og <strong>startTreatment(Patient)</strong>).</li>
</ul>

<h1 id="typer---teorisp√∏rsm√•l">Typer - Teorisp√∏rsm√•l</h1>

<ol>
  <li>**Collection<String> strings = new ArrayList<String>()**
a) Hva er sammenhengen med typen deklarert p√• venstre-side og typen deklarert p√• h√∏yre-side?
Hvordan p√•virker **String**-spesialiseringen (alts√• det som st√•r mellom **&lt; &gt;**) bruken av **strings**-variabelen?
</String></String>    <ul>
      <li>Typen p√• h√∏yresiden m√• v√¶re den samme eller en subklasse (inkl. implementasjonsklasse, som her) av typen p√• venstresiden. Spesialiseringen m√• v√¶re den samme. <strong>String</strong>-spesialiseringen p√•virker parametertyper og returtyper for <strong>Collection</strong>- og <strong>ArrayList</strong>-metodene. F.eks. vil <strong>get</strong> returnere <strong>String</strong> og <strong>add</strong> og <strong>set</strong>-metodene vil ta en <strong>String</strong> som parameter.
b) Hvordan p√•virker det videre programmering at det st√•r <String>?</String></li>
    </ul>
  </li>
  <li>
    <p>Hva er casting?</p>
  </li>
  <li>
    <p>a) Hva er forskjellen p√• int og Integer?
b) Gi et eksempel p√• n√•r en m√• bruke Integer.</p>
  </li>
  <li>
    <p>Hva er typen til f√∏lgende uttrykk? 
a) ‚ÄúJava‚Äù + ‚ÄúG√∏y‚Äù;  // String + String = String
b) 1/2;  // int / int = int
c) (‚ÄúJ‚Äù+‚Äùava‚Äù).charAt(2);  // char</p>
  </li>
  <li>Public Eksamen(String besvarelser‚Ä¶){} 
Hvor mange String-objekter kan sendes inn i denne konstrukt√∏ren?</li>
</ol>

<p>Man m√• deklarere <em>typen</em> til alle felt, variabler og parametre (i motsetning f.eks. Python, Javascript og Matlab). De viktigste fordelene er at det blir lettere √•:</p>

<ol>
  <li>
    <p>oppdage/hindre feil bruk av verdier (for verkt√∏y, kompilator og programmerer)</p>
  </li>
  <li>
    <p>tilby hjelp til kodingen, f.eks. foresl√• metoder</p>
  </li>
  <li>
    <p>kompilere til effektiv kode</p>
  </li>
</ol>

<p>At metoder i en klasse kan ha samme navn kalles ‚Äúoverloading‚Äù. For √• avgj√∏re hvilken som skal kalles, brukes de deklarerte typene til argumentene (ikke returverdien). Merk at dette er noe annet enn polymorfi, som handler om at subklasser kan ha ulike implementasjoner av metoder definert i en felles superklasse.</p>

<p>Hensikten med √• definere en <strong>toString()</strong>-metode er at <strong>toString()</strong>-metoden brukes implisitt n√•r Java lager String-objekter av instanser ifm. bruk av <strong>+</strong> og IO og sikrer at tilstanden til instanser blir presentert p√• en nyttig m√•te.</p>

<p>Hvordan er klassen kodet s√• det forklarende ordet/navnet vises ved utskrift, f.eks. med <strong>System.out.println(‚Ä¶)</strong>? Ved utskrift s√• brukes implisitt <strong>toString()</strong>-metoden, som er implementert og returnerer <strong>label</strong>.</p>

<p>Et funksjonelt grensesnitt har bare √©n abstrakt metode, og resultatet av √• utf√∏re metoden skal alltid v√¶re det samme for samme argumenter. Dette gj√∏r at man kan tenke p√• implementasjonen som en matematisk funksjon. Det er ogs√• et poeng (men underordnet) at grensensittet er ment √• v√¶re den <em>prim√¶re</em> funksjonen til klassen som implementerer den. Ellers gir det ikke s√• mye mening √• bruke anonyme klasser/lambda-uttrykk til √• implementere grensesnittet. Et eksempel p√• dette er <strong>Comparator</strong>, som kun implementeres for √• sammenligne argumentene. <strong>Comparable</strong>-derimot, implementeres av dataklasser og er derfor en sekund√¶r funksjon, som det ikke er noe poeng √• implementere som prim√¶rfunksjon.</p>

<p><strong>DiceScorer</strong>-grensesnittet er funksjonelt fordi det 1) har kun √©n abstrakt metode og 2) er ment √• v√¶re prim√¶rtfunksjonen til klassen som implementerer den.</p>

<p>Funksjonelle grensesnitt har bare √©n metode (krav 1), og den metoden er <em>funksjonell</em> fordi den for samme input(-parametre) alltid gir samme output(-verdi). En annen m√•te √• si det siste p√• er at den ikke har intern tilstand som p√•virker oppf√∏rselen og som kan endres. Det er ogs√• vanlig √• tenke p√• grensesnitt-metoden som klassens <em>hovedfunksjon</em>.</p>

<p><strong>CapacityListener</strong>-grensesnitt er (teknisk sett) funksjonelt, siden det bare har √©n (abstrakt) metode (og kan derfor implementeres med lambda-syntaksen). Dette kreves i et svar som f√•r poeng i det hele tatt. I tillegg b√∏r andre argumenter (for at grensesnittet ikke er funksjonelt) trekkes inn, f.eks. at metoden typisk ikke er implementasjonens prim√¶re funksjon og at en ikke tenker p√• den som en matematisk funksjon som kun er avhengig av argumentene.</p>

<p>Hjelpemetode <strong>tokenize</strong>, som kan v√¶re nyttig ved innlesing og som kan antas ferdig implementert. Modifikatorer?
En slik hjelpemetode b√∏r for det f√∏rste v√¶re markert som <strong>private</strong>, siden det ikke er naturlig at dette er en tjeneste som tilbys andre klasser. For det andre b√∏r den v√¶re markert som <strong>static</strong>, siden den ikke bruker (leser eller endrer) tilstanden til noe <strong>Family</strong>-objekt. Eneste grunn til at den ikke skal v√¶re <strong>static</strong>, er hvis en subklasse av <strong>Family</strong> har behov for √• redefinere den, og det er ikke aktuelt her.</p>

<p>Her er poenget at en trenger en <em>global</em> teller, som en f√•r til i Java ved bruk av <strong>static</strong>. Denne m√• brukes og √∏kes i <strong>Table</strong> sin konstrukt√∏r.</p>

<h1 id="testing---teorisp√∏rsm√•l">Testing - Teorisp√∏rsm√•l</h1>

<ol>
  <li>
    <p>Hvilke tre ‚Äúfaser‚Äù g√•r man gjennom under kj√∏ring av en JUnit-test?</p>

    <ol>
      <li>Hva m√• de ulike metodene i hver ‚Äúfase‚Äù hete?</li>
    </ol>
  </li>
  <li>
    <p>Hvor mange test- metoder kan en JUnit-test inneholde?</p>
  </li>
  <li>
    <p>Hva er meningen med testing av programmer p√• enhetsniv√• (Slik JUnit gj√∏r)?</p>
  </li>
</ol>

<p>Den <em>generelle</em> testeteknikken som JUnit-testing (og JExercise) baserer seg p√• er √• rigge opp objekter med en f√∏r-tilstand, endre tilstanden og sammenligne med forventet etter-tilstand. Noen ganger er det ingen f√∏r- og etter-tilstand, da en kun sjekker et selvstendig metodekall, dvs. sammenligner returverdi med fasiten.</p>
<ul>
  <li>bruk av <strong>assertTrue</strong> og <strong>==</strong> og **ikke assertEquals **for √• sjekke for identisk likhet.</li>
</ul>

<p>For √• teste iterasjon med foreach-l√∏kker, m√• vi bruke metoden som en slik l√∏kke (implisitt) bruker, nemlig <strong>iterator()</strong>-metoden og <strong>Iterator</strong>-objektet som denne returnerer. Her brukes objektene som er rigget opp i <strong>setUp</strong>-metoden.</p>

<p>hvorfor det er mer komplisert √• teste <strong>rentBike</strong> og <strong>returnBike</strong> enn √• teste <strong>getRentedBikes</strong>. Hvilke aspekter ved disse metodene er det som gj√∏r det mer komplisert?</p>
<ul>
  <li><strong>getRentedBikes</strong> kan testes ved √• sjekke bare returverdier, etter √• ha rigget opp diverse objekter, siden metoden ikke har <em>side-effekter</em>. Effekten av <strong>rentBike</strong> og <strong>returnBike</strong> er derimot endring av diverse datastrukturer, s√• disse m√• sjekkes etterp√•.</li>
</ul>

<h1 id="unntakexception">Unntak/Exception</h1>

<p>I metoder som endrer (en verdi i) et objekt, s√• b√∏r argumenter valideres. Dette m√• skje f√∏r selve endringen og i tilfelle ugyldig(e) verdier s√• kastes et unntak av typen <strong>IllegalArgumentException(‚Ä¶)</strong>.</p>

<p>En s√•kalt <em>checked exception</em> er en subklasse av Exception som ikke samtidig er en subklasse av RuntimeException. En slik Exception m√• deklareres vha. <strong>throws</strong> og den kallende metoden m√• enten h√•ndtere unntaket med <strong>try</strong>/<strong>catch</strong> eller deklarere det med <strong>throw</strong>s.</p>

<p>Checked exception : en <strong>Exception</strong> som ikke er en <strong>RuntimeException</strong> er en <em>checked</em> exception. En slik unntakstype krever enten try/catch eller en <strong>throws</strong>-deklarasjon for √• unng√• kompileringsfeil.</p>

<p>Metoder som sjekker argumentene sine f√∏r de utf√∏rer evt. endringer p√• objektet kalles <em>validering</em> (og er en viktig del av innkapsling). Det er lurt √• skille ut valideringen i en egen metode som kalles fra endringsmetodene. Metoden kan v√¶re <strong>protected</strong>, s√• subklasser kan redefinere og gjenbruke valideringslogikken. Det er vanligst √• bruke en s√•kalt <em>unchecked exception</em> (usjekket unntak), som <strong>IllegalArgumentException</strong>.</p>

<p><strong>throws</strong>-deklarasjonen forteller leseren av koden at konstrukt√∏rene kan utl√∏se unntak. Siden unntakene er en subklasse av <strong>RuntimeException</strong> og dermed ikke <em>checked</em>, s√• er det ikke n√∏dvendige.</p>

<h1 id="ulike-grensesnitt-typer">Ulike grensesnitt typer</h1>

<p>Standard funksjonelle grensesnitt, inkl. **Predicate<T>**, **Consumer<T>**, **Supplier<T>**, **Function&lt;T, R&gt;**, **BiFunction&lt;T1, T2, R&gt;**, **BinaryOperator<T>** og **UnaryOperator<T>**</T></T></T></T></T></p>

<p>Grensesnitt som <strong>Predicate</strong> er et s√•kalt <em>funksjonelt</em> grensesnitt, siden det har √©n metode som (er ment som √•) oppf√∏rer seg som en matematisk funksjon.</p>

<p>Metoden deklareres som **Collection<Person> getMatchingPersons(Collection<Person> persons, Predicate<Person> test)**. Koden kan skrives p√• (minst) to m√•ter, enten som en √©n-linjer med **Stream**-teknikken eller med en l√∏kke som tester og legger til en resultat-liste. Kallet gj√∏res enklest med lambda-notasjonen:
**getMatchingPersons(persons, p -&gt; p.getGender() == ‚ÄôM‚Äô &amp;&amp; p.getAge() == 18)**</Person></Person></Person></p>

<p>Collection-rammeverket** (Collection<T>-, List<T>-, Set<T>, Map&lt;K, V&gt;-, Iterator<T>- og Iterable<T>-**grensesnittene og** ArrayList<T>- og HashMap&lt;K, V&gt;-klassene)**, inkludert bruk av **&lt;&gt; **i deklarasjoner, s√•kalte generics
Hvis en klasse implementerer **Iterable** s√• kan en bruke en instans av klassen p√• h√∏yresiden av :-tegnet i en for-each-l√∏kka, og iterere over alle verdier "inni" objektet. Her betyr det at vi kan skrive ... **for (double v : values) { ... }**</T></T></T></T></T></T></p>

<p>Typen b√∏r v√¶re et grensesnitt fra <strong>Collection</strong>-rammeverket, enten <strong>Collection</strong> eller <strong>List</strong>, som er spesialisert til element-typen <strong>Course</strong>. Her brukes <strong>Collection</strong>, fordi en ikke trenger andre metoder enn den deklarerer.</p>

<p>Her er poenget √• velge en type som passer til hvordan feltet brukes og verdien den blir tilordnet. Verdien som tilordnes er av typen **List<Course>**, s√• typen m√• enten v√¶re **List** eller en av dens superklasser, som er **Collection** og **Iterable**. Hvis vi bare trenger metodene i **Collection**, som **List** arver fra, s√• er det bedre √• bruke **Collection** i deklarasjonen.</Course></p>

<p>For √• kunne iterere med et <strong>Meal</strong>-objekt bak kolonet i en <strong>for</strong>-l√∏kke, s√• m√• <strong>Meal</strong>-klassen implementere **Iterable<Course>** og derfor ha en **iterator()**-metode som returnerer **Iterator<Course>**.</Course></Course></p>

<p>Her er poenget √• skj√∏nne hvordan tabeller virker (opprettes, leses fra og skrives til) og logikken bak <strong>valueCounters</strong>-feltet, samt hvordan iterere med <strong>Iterator</strong> (<strong>hasNext()</strong> og <strong>next()</strong>) og <strong>Iterable</strong> (<strong>iterator()</strong>).</p>

<p>En kan lage en egen klasse som kombinerer mobilnummer og antall minutter i forkant de skal f√• varsel, eller bruke en <strong>Map&lt;String, Integer&gt;</strong>.</p>

<p>Hvis en klasse implementerer <strong>Iterable</strong>, s√• kan referanser til denne klassen brukes p√• h√∏yresiden av kolonet i en for-each-l√∏kke, f.eks. for (Person child : person). Se ogs√• <strong>getChildren</strong>-koden over.
Et (litt mindre relevant, og ikke p√•krevd) alternativ er **Iterable.forEach(Consumer<Person>)**. Dette er en s√•kalt **default**-metode (kom ikke frem i vedlegget) som en f√•r gratis n√•r en implementerer **Iterable**.</Person></p>

<p>Forklar med tekst og kode sammenhengen mellom for-each-syntaksen, alts√• den p√• formen for (<type> <var> : <uttrykk>) ..., og **Iterable**- og **Iterator**-grensesnittene.</uttrykk></var></type></p>
<ul>
  <li>Den vanlige m√•ten √• g√• gjennom en liste med elementer er med kode som den under til venstre. Dette kalles en <strong>for-each</strong>-l√∏kke, fordi den g√•r gjennom hvert element i lista. Dette er egentlig spesial-syntaks for iterator-basert iterasjon, det er bare det at du aldri ser iteratoren. Funksjonelt sett er <strong>for-each</strong>-l√∏kka til venstre ekvivalent med den <strong>Iterator</strong>-baserte l√∏kka under til h√∏yre. Det er egentlig en smaksak hvilken en bruker, men den venstre varianten er √• foretrekke fordi den b√•de er enklere √• skrive og lese.</li>
  <li>Hvis en tenker over det, s√• er det nettopp <strong>iterator()</strong>-metoden, som er n√∏kkelen til at <strong>for-each</strong>-l√∏kka virker. Det holder at <strong>stringListe</strong> i kode-eksemplet har en slik metode, for at den skal kunne ‚Äúomskrives‚Äù til koden til h√∏yre som den tilsvarer. Denne koblingen mellom <strong>for-each</strong>-l√∏kka og <strong>iterator()</strong>-metoden er ikke tilfeldig, og for √• gj√∏re koblingen eksplisitt og mulig √• utnytte for klasser utenfor Collection-rammeverket, s√• er <strong>iterator()</strong>-metoden definert i et eget grensesnitt ved navn <strong>Iterable</strong> (i <strong>java.lang</strong>-pakken, s√• en slipper egen import-setning). Det er alts√• fordi en <strong>ArrayList</strong> implementerer <strong>Iterable</strong> at en <strong>for-each</strong>-l√∏kke med en <strong>ArrayList</strong> virker! Og <strong>ArrayList</strong> implementerer <strong>Iterable</strong> fordi den implementerer <strong>List</strong>, og <strong>List</strong> utvider <strong>Collection</strong> som utvider <strong>Iterable</strong>. Denne koblingen mellom <strong>ArrayList</strong> og <strong>Iterable</strong> er illustrert under med et klassediagram:</li>
</ul>

<p>sortering med** Comparable<T> **og** Comparator<T>**</T></T></p>

<p>Ved √• implementere <strong>Comparable</strong>-grensesnittet s√• kan <strong>Value</strong>-objekter sorteres vha. Java sine innebygde sort-metoder.</p>

<p>Dersom <strong>Course</strong>-klassen implementerer <strong>Comparable</strong>, dvs. sammenligning med et annet <strong>Course</strong>-objekt, s√• kan <strong>Collections.sort</strong>- og <strong>List.sort</strong>-metodene brukes til sortering av <strong>Course</strong>-objekter.</p>

<p><strong>Exam</strong>-objekter skal ogs√• kunne sorteres, men p√• <strong>to m√•ter</strong>! Hvordan begge sorteringene kan st√∏ttes og skriv n√∏dvendig kode : I tillegg til <strong>Comparable</strong>, som bygger sorteringsrekkef√∏lgen inn i klassen selv, s√• kan en implementere en **Comparator<Exam>**, som er en annen klasse som sammenligne to **Exam**-objekter:</Exam></p>

<p><strong>Table</strong> m√• implementere <strong>Comparable&lt;Table&gt;</strong> for at <strong>sort</strong>-metoden skal kunne brukes og virke. Alternativt kan man lage en (implementasjon av) <strong>Comparator&lt;Table&gt;</strong>, f.eks. med <strong>(t1,t2) -&gt; t1.getCapacity() ‚Äì t2.other.getCapacity()</strong>.</p>

<p>IO med byte- og tegnstr√∏mmer <strong>(InputStream/OutputStream **og</strong> Reader/Writer **med subklasser) og filer</p>

<ul>
  <li>
    <p><strong>InputStream</strong>-/<strong>OutputStream</strong>-klassene h√•ndterer <strong>byte</strong>-verdier, mens <strong>Reader</strong>-/<strong>Writer</strong>-klassene h√•ndterer char-verdier (dvs. implementerer koding av tegn til/fra bytes iht. Unicode-regler).</p>
  </li>
  <li>
    <p>Input/output-metoder kaster ofte <strong>IOException</strong>, som er en s√•kalt ‚Äúchecked exception‚Äù. Slike brukes gjerne for feil som er utenfor v√•r kontroll. Disse krever at kode m√• fange dem opp med <strong>try/catch</strong> eller deklarere med <strong>throws</strong> at de kastes videre.</p>
  </li>
  <li>
    <p>Str√∏mmer bruker gjerne ressurser utenfor Java og <strong>close()</strong>-metoden sikrer at Java samhandler riktig med disse, f.eks. frigj√∏r dem. For √• sikre at dette alltid skjer, er det vanlig √• ha <strong>close()</strong>-kallet i en <strong>try/finally</strong>-blokk.</p>
  </li>
</ul>

<h1 id="streams">Streams</h1>

<p>return allBikes.stream().filter(bike -&gt; bike.getRenter() == null &amp;&amp; bike.getLocation().distance(location) &lt;= distance).count();</p>

<p>return allBikes.stream().filter(bike -&gt; bike.getRenter() != null).collect(Collectors.toList());</p>

<p>getRentedBikes().stream().filter(bike -&gt; getStationNearby(bike, 30.0) != null).collect(Collectors.toList());</p>

<p>diceCol.stream().map(Dice::getScore).reduce(0, (n1, n2) -&gt; n1 + n2)</p>

<p>diceCol.stream().mapToInt(Dice::getScore).sum()</p>

<h1 id="inputoutput-io">Input/Output (IO)</h1>

<p>Det viktigste med <strong>save</strong>-metoden er at den f√∏rst skriver ut alle linjer av type 1, alts√• den person-informasjonen som er n√∏dvendig for √• <strong>lage</strong> Person-objektene f√∏r foreldre-barn-koblingen etableres. Vi velger √• lage en <strong>PrintWriter</strong> rundt <strong>OutputStream</strong>-en vi f√•r inn, for √• muliggj√∏re bruke av <strong>print</strong> og <strong>println</strong>. Vi kunne brukt en <strong>PrintStream</strong>, men en <strong>Writer</strong> anbefales jo for tekst (trekker ikke for bruk av <strong>PrintStream</strong>). S√• skrives alle linjene av type 2 ut. Derfor blir det to iterasjoner over alle medlemmene. Navn f√•r anf√∏rselstegn (‚Äú) rundt (merk m√•ten ‚Äù inkluderes i en String). Her sjekkes det om en person har barn (kan gj√∏re p√• mange m√•ter), s√• det ikke blir linjer med en forelder, men det er strengt tatt ikke definert som et krav (det st√•r ‚Äùsequence of names‚Äù, og en sekvens kan jo ha bare ett element). Hvis en har linjer med bare √©n forelder, s√• er det viktig at load-metoden h√•ndterer det riktig. Det er vanlig at den som setter opp en <strong>OutputStream</strong> ogs√• lukker den, og derfor avslutter vi <em>ikke</em> med <strong>pw.close()</strong>. Vi avslutter imidlertid med <strong>pw.flush()</strong> for √• sikre at all v√•r output sendes ut med en gang (trekker ikke for manglende bruk av <strong>close()</strong>/<strong>flush()</strong>).</p>

<p><strong>load</strong>-metoden klassifiserer hver linje som en av de tre typene ved √• f√∏rst sjekke om den er tom eller starter med # (type 3) og s√• sjekker om f√∏rste token i en linje er en gyldig <strong>Gender</strong> (type 1). Ellers er den av type 2. Her gj√∏res det ingen sjekk p√• om formatet er korrekt, f.eks. om et barn i en linje av type 2 faktisk er registrert som familiemedlem. Det er kanskje litt uklart hvorvidt og evt. hvordan <strong>tokenize</strong> h√•ndterer <strong>#</strong>, s√• det er greit at den brukes f√∏r en sjekker for linjer av type 3.</p>

<p>Unntak h√•ndteres ikke av metodene, s√• de m√• deklareres med <strong>throws</strong>. Det er naturlig √• bruke <strong>IOException</strong>, for den utl√∏ses ved bruk av <strong>InputStream</strong> og <strong>OutputStream</strong>. En kunne brukt <strong>Exception</strong> or √• markere (at vi er klar over) at det er mye som kan g√• galt, men det anbefales √• bruke den mest spesifikke typen. Vi kunne fanget opp og ignorert unntak, men det kan lett maskere feil vi √∏nsker √• avdekke.</p>

<p><strong>public void save(OutputStream out) throws IOException {</strong></p>

<p><strong>PrintWriter pw = new PrintWriter(out);</strong></p>

<p><strong>‚Ä¶</strong></p>

<p><strong>pw.flush()</strong></p>

<p><strong>}
public void load(InputStream in) throws IOException {</strong></p>

<p><strong>Scanner scanner = new Scanner(in);</strong></p>

<p><strong>‚Ä¶</strong></p>

<p><strong>scanner.close();</strong></p>

<p><strong>}</strong></p>

<h1 id="fxml">FXML</h1>

<p>Av FXML-koden kan en lese at det grafiske grensesnittet (appen) knyttes til <strong>BikeRental</strong> ved hjelp av klassen <strong>BikeRentalController</strong>. Dette er i tr√•d med navnekonvensjonene brukt i tidligere eksamener. Det refereres til to tekstfelt som en i koden kobler seg til med henholdsvis  @FXML private TextField <strong>fromInput</strong> og <strong>toInput</strong>. Likeledes m√• en lage tre metoder (@FXML private void <strong>plus1HourAction</strong>, <strong>minus1HourAction</strong> og <strong>rentAction</strong>) som kalles n√•r knappene i grensesnittet trykkes inn.</p>

<p>Her er vi mest opptatt av:
	- @FXML-annotasjonene
	- riktig type og navn for variablene og metoden
	- at en henter input fra <strong>dieCountInput</strong> og setter output med <strong>diceOutput</strong></p>

<h1 id="diagrammer">Diagrammer</h1>

<p>Grovt sett beskriver diagrammer to ulike aspekter ved et program:</p>

<ul>
  <li>
    <p>Tilstand/oppf√∏rsel ved kj√∏retid, alts√• hva som skjer n√•r programmet kj√∏res, f.eks. tilstanden til objektstrukturer. Eksempler er **<a href="https://www.ntnu.no/wiki/display/tdt4100/Objekttilstandsdiagrammer">Objektdiagramme<strong>r](https://www.ntnu.no/wiki/display/tdt4100/Objektdiagrammer), **[Objekttilstandsdiagramme</strong>r</a> og **<a href="https://www.ntnu.no/wiki/display/tdt4100/Sekvensdiagrammer">Sekvensdiagramme**r</a>.</p>
  </li>
  <li>
    <p>Design, alts√• hvordan programkoden er strukturert, f.eks. hvilke klasser som finnes og hvordan de henger sammen. **<a href="https://www.ntnu.no/wiki/display/tdt4100/Klassediagrammer">Klassediagramme**r</a> er et eksempel.</p>
  </li>
</ul>

<p>PLANTUML</p>

<ul>
  <li>Hide circle : hides class/interface/abstract icon</li>
</ul>

<p>De ulike diagramdelene, alts√• boksene, strekene/pilene og tegnene (ord, tall og <em>):
Diagrammet er omtrent som et klassediagram, s√• boksene tilsvarer klasser. Navnet √∏verst en boks er klassenavnet, mens de andre er egenskaper, dvs. data, som instansene vil ha. Strekene er assosiasjoner (eller relasjoner), som sier noe om hvordan instanser kan kobles sammen. Tallene p√• enden av strekene angir hvor mange koblinger en instans kan ha (</em> betyr ubegrenset), s√•kalt <em>multiplisitet</em>. Pilene sier noe om i hvilken retning en kan f√∏lge en kobling, ingen betyr begge retninger, mens √©n pil betyr bare i den retningen.
Egenskapene og assosiasjonene blir typisk til felt med type som passer til multiplisiteten. En m√• velge hvordan dataene skal <em>kapsles inn</em>, alts√• konstrukt√∏rer med parametre, gettere og settere, og evt. add- og remove-metoder og andre metoder.</p>

<p><strong>O</strong><strong>bjektdiagrammer (objekter med tilstand og koblinger)</strong></p>

<p>er en diagramtype som viser tilstanden til et program, ved √• illustrere ‚Äúsnapshots‚Äù av objektstrukturer.</p>

<p>Hva er forskjellen (hensikt og innhold) mellom <em>objektdiagrammer *og *objekttilstandsdiagrammer</em>?</p>

<p>Et <em>objektdiagram</em> viser oppbygning av og koblinger mellom objekter/instanser, og brukes for √• illustrere tilstanden til (eller en mulig tilstand til) et program. Et <em>objekttilstandsdiagram</em> viser hvordan slike strukturer endres over tid, ved kall av metoder (typisk endringsmetoder), og brukes til √• illustrere (mulig) objektoppf√∏rsel og utviklingen av tilstanden til et program.</p>

<p><strong>O</strong><strong>bjekttilstandsdiagrammer</strong></p>

<p>Hvis en tenker p√• objektdiagrammer som tilstander og kobler dem sammen med transisjoner, s√• f√•r en objekttilstandsdiagram, som viser hvordan objektstrukturer utvikler seg over tid.</p>

<p>Objekttilstandsdiagrammer brukes til √• beskrive oppf√∏rselen til et objekt. Viktig fordel og ulempe/begrensning.</p>

<ul>
  <li>
    <p><strong>Fordeler</strong>: Eksempel p√• forl√∏p kan v√¶re enklere √• forst√• enn en komplett definisjon i form av regler (invarianter). Diagrammer kan v√¶re mer intuitive enn tekst. Det er lett √• skrive test-kode basert p√• diagrammet.</p>
  </li>
  <li>
    <p><strong>Ulemper</strong>: Diagrammene blir lett store, hvis de skal dekke alle relevante tilfeller. Det er kun i enkle tilfeller en kan beskrive oppf√∏rselen komplett.</p>
  </li>
</ul>

<p><img src="image_0.png" alt="image alt text" /></p>

<p><strong>S</strong><strong>ekvensdiagrammer</strong></p>

<p>Interaksjonsdiagrammer viser hvordan objekter i en objektstruktur bruker hverandre, dvs. kaller hverandres metoder. Det finnes to varianter: samhandlingsdiagrammer utvider objektdiagrammer med visning av (sekvenser av) metodekall, og sekvensdiagrammer viser metodekall mellom objekter langs en tidslinje.</p>

<p><strong>K</strong><strong>lassediagrammer (klasser og assosiasjoner inkl. kardinalitet)</strong></p>

<p>viser klassestrukturen til et program, med innholdet i klasser (attributter og operasjoner) og hvordan de er koblet sammen med arv og assosiasjoner.</p>

:ET